var Xi=Object.defineProperty;var es=(e,n,t)=>n in e?Xi(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t;var a=(e,n,t)=>es(e,typeof n!="symbol"?n+"":n,t);const Me=e=>Array.isArray(e)?e:[e],ts=(e,n)=>{const t=[[],[]];for(const r of e)n(r)?t[0].push(r):t[1].push(r);return t},ur=Array,te=(e,n)=>e.includes(n),ns=(e,n=0)=>[...new Array(e)].map((t,r)=>r+n),w=(e,n,t)=>e===void 0?n===void 0?[]:Array.isArray(n)?n:[n]:(Array.isArray(n)?e.push(...n):e.push(n),e),re=(e,n)=>n==null?e??[]:e==null?Me(n):e.concat(n),rs=(...e)=>e.reduce(re,[]),ie=(e,n,t)=>{if(e===void 0)return Array.isArray(n)?n:[n];const r=(t==null?void 0:t.isEqual)??((i,s)=>i===s);for(const i of Me(n))e.some(s=>r(s,i))||e.push(i);return e},is=(e,n)=>e.reduce((t,r)=>{const i=r[n];return t[i]=w(t[i],r),t},{}),pe=(e,n,t)=>e.length===n.length&&e.every(t!=null&&t.isEqual?(r,i)=>t.isEqual(r,n[i]):(r,i)=>r===n[i]),oe=(e,n)=>F(e)===n,F=e=>{const n=typeof e;return n==="object"?e===null?"null":"object":n==="function"?"object":n},_={boolean:"boolean",null:"null",undefined:"undefined",bigint:"a bigint",number:"a number",object:"an object",string:"a string",symbol:"a symbol"},ss={..._,function:"a function"};class os extends Error{}const M=e=>me(e,os),me=(e,n=Error)=>{throw new n(e)};class as extends Error{constructor(){super(...arguments);a(this,"name","ParseError")}}const h=e=>me(e,as),dr=e=>` ${e}`,N=(e,n)=>{const t={},r=Array.isArray(e);let i=!1;for(const[s,o]of Object.entries(e).entries()){const c=r?n(s,o[1]):n(...o,s);i||(i=typeof c[0]=="number");const l=Array.isArray(c[0])||c.length===0?c:[c];for(const[u,d]of l)typeof u=="object"?t[u.group]=w(t[u.group],d):t[u]=d}return i?Object.values(t):t},hr=Object.entries,T=(e,n)=>e in n,jt=(e,n)=>n in e;class cs{constructor(n){Object.assign(this,n)}}const ls=class{};class fr extends ls{}const us=(e,n)=>{const t={},r={};let i;for(i in e)i in n?t[i]=e[i]:r[i]=e[i];return[t,r]},ds=(e,n)=>us(e,n)[1],Re=e=>Object.keys(e).length===0,Ve=e=>[...Object.entries(e),...Object.getOwnPropertySymbols(e).map(n=>[n,e[n]])],hs=(e,n)=>Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)),fs=e=>{const n=Object.keys(e).sort(),t={};for(let r=0;r<n.length;r++)t[n[r]]=e[n[r]];return t},V=dr("represents an uninitialized value"),ps=e=>Object.values(e).filter(n=>typeof n=="number"?!0:typeof e[n]!="number"),pr={Array,Boolean,Date,Error,Function,Map,Number,Promise,RegExp,Set,String,WeakMap,WeakSet},mr=globalThis.File??Blob,gr={ArrayBuffer,Blob,File:mr,FormData,Headers,Request,Response,URL},ms={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,BigInt64Array,BigUint64Array},ge={...pr,...gr,...ms,String,Number,Boolean},Ft=e=>{var r;let n=Object.getPrototypeOf(e);for(;n!=null&&n.constructor&&(!T(n.constructor.name,ge)||!(e instanceof ge[n.constructor.name]));)n=Object.getPrototypeOf(n);const t=(r=n==null?void 0:n.constructor)==null?void 0:r.name;if(!(t===void 0||t==="Object"))return t},vt=e=>typeof e=="object"&&e!==null?Ft(e)??"object":F(e),B=Array.isArray,gs={Array:"an array",Function:"a function",Date:"a Date",RegExp:"a RegExp",Error:"an Error",Map:"a Map",Set:"a Set",String:"a String object",Number:"a Number object",Boolean:"a Boolean object",Promise:"a Promise",WeakMap:"a WeakMap",WeakSet:"a WeakSet"},ys={ArrayBuffer:"an ArrayBuffer instance",Blob:"a Blob instance",File:"a File instance",FormData:"a FormData instance",Headers:"a Headers instance",Request:"a Request instance",Response:"a Response instance",URL:"a URL instance"},bs={Int8Array:"an Int8Array",Uint8Array:"a Uint8Array",Uint8ClampedArray:"a Uint8ClampedArray",Int16Array:"an Int16Array",Uint16Array:"a Uint16Array",Int32Array:"an Int32Array",Uint32Array:"a Uint32Array",Float32Array:"a Float32Array",Float64Array:"a Float64Array",BigInt64Array:"a BigInt64Array",BigUint64Array:"a BigUint64Array"},$s={...gs,...ys,...bs},Ut=e=>{const n=Object(e).name??null;return n&&T(n,ge)&&ge[n]===e?n:null},sn=(e,n)=>{let t=e.prototype;for(;t!==null;){if(t===n.prototype)return!0;t=Object.getPrototypeOf(t)}return!1},xs=e=>yr(e,new Map),yr=(e,n)=>{if(typeof e!="object"||e===null)return e;if(n!=null&&n.has(e))return n.get(e);const t=Ut(e.constructor);if(t==="Date")return new Date(e.getTime());if(t&&t!=="Array")return e;const r=Array.isArray(e)?e.slice():Object.create(Object.getPrototypeOf(e)),i=Object.getOwnPropertyDescriptors(e);if(n){n.set(e,r);for(const s in i){const o=i[s];"get"in o||"set"in o||(o.value=yr(o.value,n))}}return Object.defineProperties(r,i),r},vs=e=>{let n=V;return()=>n===V?n=e():n},tt=e=>typeof e=="function"&&e.length===0,ks=class extends Function{constructor(...e){const n=e.slice(0,-1),t=e.at(-1);try{super(...n,t)}catch(r){return M(`Encountered an unexpected error while compiling your definition:
                Message: ${r} 
                Source: (${e.slice(0,-1)}) => {
                    ${e.at(-1)}
                }`)}}};class $e{constructor(n,...[t]){return Object.assign(Object.setPrototypeOf(n.bind((t==null?void 0:t.bind)??this),this.constructor.prototype),t==null?void 0:t.attach)}}const ws=vs(()=>{try{return new Function("return false")()}catch{return!0}});class J{constructor(){}}const Ns=()=>{var e,n,t;try{return(((t=(((n=(e=new Error().stack)==null?void 0:e.split(`
`)[2])==null?void 0:n.trim())||"").match(/\(?(.+?)(?::\d+:\d+)?\)?$/))==null?void 0:t[1])||"unknown").replace(/^file:\/\//,"")}catch{return"unknown"}};var Yn;const As=((Yn=globalThis.process)==null?void 0:Yn.env)??{},Is={fileName:Ns,env:As},Ss=e=>e[0].toUpperCase()+e.slice(1),br=e=>new RegExp(Os(e),typeof e=="string"?"":e.flags),Os=e=>`^(?:${typeof e=="string"?e:e.source})$`,Q={negativeLookahead:e=>`(?!${e})`,nonCapturingGroup:e=>`(?:${e})`},kt="\\",nt={" ":1,"\n":1,"	":1},Ms=/^-0\.?0*$/.source,$r=/[1-9]\d*/.source,Rs=/\.\d+/.source,Ks=/\.\d*[1-9]/.source,xr=e=>br(Q.negativeLookahead(Ms)+Q.nonCapturingGroup("-?"+Q.nonCapturingGroup(Q.nonCapturingGroup("0|"+$r)+Q.nonCapturingGroup(e.decimalPattern)+"?")+(e.allowDecimalOnly?"|"+e.decimalPattern:"")+"?")),on=xr({decimalPattern:Ks,allowDecimalOnly:!1}),qs=on.test.bind(on),wt=xr({decimalPattern:Rs,allowDecimalOnly:!0});wt.test.bind(wt);const Cs=/^-?\d*\.?\d*$/,Ds=e=>e.length!==0&&Cs.test(e),_e=br(Q.negativeLookahead("^-0$")+"-?"+Q.nonCapturingGroup(Q.nonCapturingGroup("0|"+$r))),Bs=_e.test.bind(_e),Nt=/^-?\d+$/,Es=Nt.test.bind(Nt),vr={number:"a number",bigint:"a bigint",integer:"an integer"},kr=(e,n)=>`'${e}' was parsed as ${vr[n]} but could not be narrowed to a literal value. Avoid unnecessary leading or trailing zeros and other abnormal notation`,Ps=(e,n)=>n==="number"?qs(e):Bs(e),zs=(e,n)=>n==="number"?Number(e):Number.parseInt(e),Ls=(e,n)=>n==="number"?Ds(e):Es(e),js=(e,n)=>Tt(e,"number",n),Fs=(e,n)=>Tt(e,"number",{...n,strict:!0}),Us=(e,n)=>Tt(e,"integer",n),Tt=(e,n,t)=>{const r=zs(e,n);return!Number.isNaN(r)&&Ls(e,n)?t!=null&&t.strict?Ps(e,n)?r:h(kr(e,n)):r:t!=null&&t.errorOnFail?h((t==null?void 0:t.errorOnFail)===!0?`Failed to parse ${vr[n]} from '${e}'`:t==null?void 0:t.errorOnFail):void 0},Ts=e=>{if(e[e.length-1]!=="n")return;const n=e.slice(0,-1);let t;try{t=BigInt(n)}catch{return}if(_e.test(n))return t;if(Nt.test(n))return h(kr(e,"bigint"))},Js="0.46.0",Vs={version:Js,filename:Is.fileName(),FileConstructor:mr},Ke=Vs,an=new Map,dt=Object.create(null),At=e=>{const n=an.get(e);if(n)return n;let t=_s(e);return dt[t]?t=`${t}${dt[t]++}`:dt[t]=1,Ke[t]=e,an.set(e,t),t},Ie=e=>/^[$A-Z_a-z][\w$]*$/.test(e),_s=e=>{switch(typeof e){case"object":{if(e===null)break;const n=Ft(e)??"object";return n[0].toLowerCase()+n.slice(1)}case"function":return Ie(e.name)?e.name:"fn";case"symbol":return e.description&&Ie(e.description)?e.description:"symbol"}return M(`Unexpected attempt to register serializable value of type ${F(e)}`)},Jt=e=>typeof e=="string"?JSON.stringify(e):typeof e=="bigint"?`${e}n`:`${e}`,Gs=(e,n={})=>Ae(e,{onUndefined:"$ark.undefined",onBigInt:t=>`$ark.bigint-${t}`,...n},[]),k=(e,n)=>{switch(F(e)){case"object":const t=e,r=t.constructor.name;return r==="Object"||r==="Array"?(n==null?void 0:n.quoteKeys)===!1?Ge(t,(n==null?void 0:n.indent)??0,""):JSON.stringify(Ae(t,ye,[]),null,n==null?void 0:n.indent):Ge(t,(n==null?void 0:n.indent)??0,"");case"symbol":return ye.onSymbol(e);default:return Jt(e)}},Ge=(e,n,t)=>{if(typeof e=="function")return ye.onFunction(e);if(typeof e!="object"||e===null)return Jt(e);const r=t+" ".repeat(n);if(Array.isArray(e)){if(e.length===0)return"[]";const s=e.map(o=>Ge(o,n,r)).join(`,
`+r);return n?`[
${r}${s}
${t}]`:`[${s}]`}const i=e.constructor.name;if(i==="Object"){const s=Ve(e).map(([o,c])=>{const l=typeof o=="symbol"?ye.onSymbol(o):Ie(o)?o:JSON.stringify(o),u=Ge(c,n,r);return`${r}${l}: ${u}`});return s.length===0?"{}":n?`{
${s.join(`,
`)}
${t}}`:`{${s.join(", ")}}`}return e instanceof Date?qe(e):"expression"in e&&typeof e.expression=="string"?e.expression:i},ye={onCycle:()=>"(cycle)",onSymbol:e=>`Symbol(${At(e)})`,onFunction:e=>`Function(${At(e)})`},Ae=(e,n,t)=>{var r,i;switch(F(e)){case"object":{const s=e;if("toJSON"in s&&typeof s.toJSON=="function")return s.toJSON();if(typeof s=="function")return ye.onFunction(s);if(t.includes(s))return"(cycle)";const o=[...t,s];if(Array.isArray(s))return s.map(l=>Ae(l,n,o));if(s instanceof Date)return s.toDateString();const c={};for(const l in s)c[l]=Ae(s[l],n,o);for(const l of Object.getOwnPropertySymbols(s))c[((r=n.onSymbol)==null?void 0:r.call(n,l))??l.toString()]=Ae(s[l],n,o);return c}case"symbol":return ye.onSymbol(e);case"bigint":return((i=n.onBigInt)==null?void 0:i.call(n,e))??`${e}n`;case"undefined":return n.onUndefined??"undefined";case"string":return e.replaceAll("\\","\\\\");default:return e}},qe=e=>{const n=e.getFullYear(),t=e.getMonth(),r=e.getDate(),i=e.getHours(),s=e.getMinutes(),o=e.getSeconds(),c=e.getMilliseconds();if(t===0&&r===1&&i===0&&s===0&&o===0&&c===0)return`${n}`;const l=`${Hs[t]} ${r}, ${n}`;if(i===0&&s===0&&o===0&&c===0)return l;let u=e.toLocaleTimeString();const d=u.endsWith(" AM")||u.endsWith(" PM")?u.slice(-3):"";return d&&(u=u.slice(0,-d.length)),c?u+=`.${Zs(c,3)}`:Ws.test(u)&&(u=u.slice(0,-3)),`${u+d}, ${l}`},Hs=["January","February","March","April","May","June","July","August","September","October","November","December"],Ws=/:\d\d:00$/,Zs=(e,n)=>String(e).padStart(n,"0"),wr=(e,n,...[t])=>{const r=(t==null?void 0:t.stringifySymbol)??k;let i=e;switch(typeof n){case"string":i=Ie(n)?e===""?n:`${e}.${n}`:`${e}[${JSON.stringify(n)}]`;break;case"number":i=`${e}[${n}]`;break;case"symbol":i=`${e}[${r(n)}]`;break;default:t!=null&&t.stringifyNonKey?i=`${e}[${t.stringifyNonKey(n)}]`:h(`${k(n)} must be a PropertyKey or stringifyNonKey must be passed to options`)}return i},Ce=(e,...n)=>e.reduce((t,r)=>wr(t,r,...n),"");class Nr extends ur{constructor(...t){super();a(this,"cache",{});this.push(...t)}toJSON(){if(this.cache.json)return this.cache.json;this.cache.json=[];for(let t=0;t<this.length;t++)this.cache.json.push(typeof this[t]=="symbol"?k(this[t]):this[t]);return this.cache.json}stringify(){return this.cache.stringify?this.cache.stringify:this.cache.stringify=Ce(this)}stringifyAncestors(){if(this.cache.stringifyAncestors)return this.cache.stringifyAncestors;let t="";const r=[t];for(const i of this)t=wr(t,i),r.push(t);return this.cache.stringifyAncestors=r}}class Ys{constructor(n){a(this,"chars");a(this,"i");a(this,"def");this.def=n,this.chars=[...n],this.i=0}shift(){return this.chars[this.i++]??""}get lookahead(){return this.chars[this.i]??""}get nextLookahead(){return this.chars[this.i+1]??""}get length(){return this.chars.length}shiftUntil(n){let t="";for(;this.lookahead;){if(n(this,t))if(t[t.length-1]===kt)t=t.slice(0,-1);else break;t+=this.shift()}return t}shiftUntilLookahead(n){return typeof n=="string"?this.shiftUntil(t=>t.lookahead===n):this.shiftUntil(t=>t.lookahead in n)}shiftUntilNonWhitespace(){return this.shiftUntil(()=>!(this.lookahead in nt))}jumpToIndex(n){this.i=n<0?this.length+n:n}jumpForward(n){this.i+=n}get location(){return this.i}get unscanned(){return this.chars.slice(this.i,this.length).join("")}get scanned(){return this.chars.slice(0,this.i).join("")}sliceChars(n,t){return this.chars.slice(n,t).join("")}lookaheadIs(n){return this.lookahead===n}lookaheadIsIn(n){return this.lookahead in n}}let It="$ark",Qs=2;for(;It in globalThis;)It=`$ark${Qs++}`;const Ar=It;globalThis[Ar]=Ke;const f=Ke,Xs=e=>`${Ar}.${e}`,z=e=>Xs(At(e));class Ir extends fr{constructor(...t){super();a(this,"argNames");a(this,"body","");a(this,"indentation",0);this.argNames=t;for(const r of t){if(r in this)throw new Error(`Arg name '${r}' would overwrite an existing property on FunctionBody`);this[r]=r}}indent(){return this.indentation+=4,this}dedent(){return this.indentation-=4,this}prop(t,r=!1){return Sr(t,r)}index(t,r=!1){return Or(`${t}`,r)}line(t){return this.body+=`${" ".repeat(this.indentation)}${t}
`,this}const(t,r){return this.line(`const ${t} = ${r}`),this}let(t,r){return this.line(`let ${t} = ${r}`)}set(t,r){return this.line(`${t} = ${r}`)}if(t,r){return this.block(`if (${t})`,r)}elseIf(t,r){return this.block(`else if (${t})`,r)}else(t){return this.block("else",t)}for(t,r,i=0){return this.block(`for (let i = ${i}; ${t}; i++)`,r)}forIn(t,r){return this.block(`for (const k in ${t})`,r)}block(t,r,i=""){return this.line(`${t} {`),this.indent(),r(this),this.dedent(),this.line(`}${i}`)}return(t=""){return this.line(`return ${t}`)}write(t="anonymous",r=0){return`${t}(${this.argNames.join(", ")}) { ${r?this.body.split(`
`).map(i=>" ".repeat(r)+`${i}`).join(`
`):this.body} }`}compile(){return new ks(...this.argNames,this.body)}}const De=e=>oe(e,"object")||typeof e=="symbol"?z(e):Jt(e),Sr=(e,n=!1)=>typeof e=="string"&&Ie(e)?`${n?"?":""}.${e}`:Or(eo(e),n),eo=e=>typeof e=="symbol"?z(e):JSON.stringify(e),Or=(e,n=!1)=>`${n?"?.":""}[${e}]`;class ht extends Ir{constructor(t){super("data","ctx");a(this,"traversalKind");a(this,"optimistic");this.traversalKind=t.kind,this.optimistic=t.optimistic===!0}invoke(t,r){const i=(r==null?void 0:r.arg)??this.data,s=typeof t=="string"?!0:this.requiresContextFor(t),o=typeof t=="string"?t:t.id;return s?`${this.referenceToId(o,r)}(${i}, ${this.ctx})`:`${this.referenceToId(o,r)}(${i})`}referenceToId(t,r){const i=(r==null?void 0:r.kind)??this.traversalKind,s=`this.${t}${i}`;return r!=null&&r.bind?`${s}.bind(${r==null?void 0:r.bind})`:s}requiresContextFor(t){return this.traversalKind==="Apply"||t.allowsRequiresContext}initializeErrorCount(){return this.const("errorCount","ctx.currentErrorCount")}returnIfFail(){return this.if("ctx.currentErrorCount > errorCount",()=>this.return())}returnIfFailFast(){return this.if("ctx.failFast && ctx.currentErrorCount > errorCount",()=>this.return())}traverseKey(t,r,i){const s=this.requiresContextFor(i);return s&&this.line(`${this.ctx}.path.push(${t})`),this.check(i,{arg:r}),s&&this.line(`${this.ctx}.path.pop()`),this}check(t,r){return this.traversalKind==="Allows"?this.if(`!${this.invoke(t,r)}`,()=>this.return(!1)):this.line(this.invoke(t,r))}}const Mr=e=>N(e,(n,t)=>[n,B(t)?[...t]:t]),G=dr("arkKind"),g=(e,n)=>(e==null?void 0:e[G])===n,P=e=>g(e,"root")||g(e,"constraint"),to=["unit","proto","domain"],rt=["required","optional","index","sequence"],Rr=["pattern","divisor","exactLength","max","min","maxLength","minLength","before","after"],Vt=[...Rr,...rt,"structure","predicate"],it=["alias","union","morph","unit","intersection","proto","domain"],no=[...it,...Vt],Kr=N(Vt,(e,n)=>[n,1]),ro=N([...rt,"undeclared"],(e,n)=>[n,1]),qr=N(no,(e,n)=>[n,e]),Te=e=>typeof e=="string"&&e in qr,He=e=>qr[e],_t=e=>it.slice(He(e)+1);[..._t("union")];[..._t("morph")];const se=e=>typeof e=="string"||typeof e=="boolean"||e===null?e:typeof e=="number"?Number.isNaN(e)?"NaN":e===Number.POSITIVE_INFINITY?"Infinity":e===Number.NEGATIVE_INFINITY?"-Infinity":e:De(e),st=e=>{let n="{ ";for(const[t,r]of Object.entries(e))n+=`${t}: ${De(r)}, `;return n+" }"},S=e=>{var t,r,i,s;const n=e;return n.hasAssociatedError&&((t=n.defaults).expected??(t.expected=o=>"description"in o?o.description:n.defaults.description(o)),(r=n.defaults).actual??(r.actual=o=>k(o)),(i=n.defaults).problem??(i.problem=o=>`must be ${o.expected}${o.actual?` (was ${o.actual})`:""}`),(s=n.defaults).message??(s.message=o=>{if(o.path.length===0)return o.problem;const c=`${o.propString} ${o.problem}`;return c[0]==="["?`value at ${c}`:c})),n};class io extends Error{constructor(t,r){super(k(r,{quoteKeys:!1,indent:4}));a(this,"name","ToJsonSchemaError");a(this,"code");a(this,"context");this.code=t,this.context=r}hasCode(t){return this.code===t}}const so={dialect:"https://json-schema.org/draft/2020-12/schema",useRefs:!1,fallback:{arrayObject:e=>R.throw("arrayObject",e),arrayPostfix:e=>R.throw("arrayPostfix",e),defaultValue:e=>R.throw("defaultValue",e),domain:e=>R.throw("domain",e),morph:e=>R.throw("morph",e),patternIntersection:e=>R.throw("patternIntersection",e),predicate:e=>R.throw("predicate",e),proto:e=>R.throw("proto",e),symbolKey:e=>R.throw("symbolKey",e),unit:e=>R.throw("unit",e),date:e=>R.throw("date",e)}},R={Error:io,throw:(...e)=>{throw new R.Error(...e)},throwInternalOperandError:(e,n)=>M(`Unexpected JSON Schema input for ${e}: ${k(n)}`),defaultConfig:so};f.config??(f.config={});const St=(e,n)=>{if(!n)return e;const t={...e};let r;for(r in n){const i={...e.keywords};if(r==="keywords"){for(const s in n[r]){const o=n.keywords[s];o!==void 0&&(i[s]=typeof o=="string"?{description:o}:o)}t.keywords=i}else r==="toJsonSchema"?t[r]=Cr(e.toJsonSchema,n.toJsonSchema):Te(r)?t[r]={...e[r],...n[r]}:t[r]=n[r]}return t},Cr=(e,n)=>{if(!e)return n??{};if(!n)return e;const t={...e};let r;for(r in n)r==="fallback"?t.fallback=oo(e.fallback,n.fallback):t[r]=n[r];return t},oo=(e,n)=>{e=cn(e),n=cn(n);const t={};let r;for(r in R.defaultConfig.fallback)t[r]=n[r]??n.default??e[r]??e.default??R.defaultConfig.fallback[r];return t},cn=e=>typeof e=="function"?{default:e}:e??{};var Qn,Xn;class be extends(Xn=fr,Qn=G,Xn){constructor({prefixPath:t,relativePath:r,...i},s){super();a(this,Qn,"error");a(this,"path");a(this,"data");a(this,"nodeConfig");a(this,"input");a(this,"ctx");this.input=i,this.ctx=s,hs(this,i);const o=s.data;i.code==="union"&&(i.errors=i.errors.flatMap(l=>{const u=l.hasCode("union")?l.errors:[l];return!t&&!r?u:u.map(d=>d.transform(p=>({...p,path:rs(t,p.path,r)})))})),this.nodeConfig=s.config[this.code];const c=[...i.path??s.path];r&&c.push(...r),t&&c.unshift(...t),this.path=new Nr(...c),this.data="data"in i?i.data:o}transform(t){return new be(t({data:this.data,path:this.path,...this.input}),this.ctx)}hasCode(t){return this.code===t}get propString(){return Ce(this.path)}get expected(){var r;if(this.input.expected)return this.input.expected;const t=((r=this.meta)==null?void 0:r.expected)??this.nodeConfig.expected;return typeof t=="function"?t(this.input):t}get actual(){var r;if(this.input.actual)return this.input.actual;const t=((r=this.meta)==null?void 0:r.actual)??this.nodeConfig.actual;return typeof t=="function"?t(this.data):t}get problem(){var r;if(this.input.problem)return this.input.problem;const t=((r=this.meta)==null?void 0:r.problem)??this.nodeConfig.problem;return typeof t=="function"?t(this):t}get message(){var r;if(this.input.message)return this.input.message;const t=((r=this.meta)==null?void 0:r.message)??this.nodeConfig.message;return typeof t=="function"?t(this):t}get flat(){return this.hasCode("intersection")?[...this.errors]:[this]}toJSON(){return{data:this.data,path:this.path,...this.input,expected:this.expected,actual:this.actual,problem:this.problem,message:this.message}}toString(){return this.message}throw(){throw this}}var er,tr;class ee extends(tr=ur,er=G,tr){constructor(t){super();a(this,er,"errors");a(this,"ctx");a(this,"byPath",Object.create(null));a(this,"byAncestorPath",Object.create(null));a(this,"count",0);a(this,"mutable",this);this.ctx=t}get flatByPath(){return N(this.byPath,(t,r)=>[t,r.flat])}get flatProblemsByPath(){return N(this.byPath,(t,r)=>[t,r.flat.map(i=>i.problem)])}throw(){throw this.toTraversalError()}toTraversalError(){return new ao(this)}add(t){this.includes(t)||this._add(t)}transform(t){const r=new ee(this.ctx);for(const i of this)r.add(t(i));return r}merge(t){for(const r of t)this.includes(r)||this._add(new be({...r,path:[...this.ctx.path,...r.path]},this.ctx))}affectsPath(t){return this.length===0?!1:t.stringifyAncestors().some(r=>r in this.byPath)||t.stringify()in this.byAncestorPath}get summary(){return this.toString()}get issues(){return this}toJSON(){return[...this.map(t=>t.toJSON())]}toString(){return this.join(`
`)}_add(t){const r=this.byPath[t.propString];if(r){if(r.hasCode("union")&&r.errors.length===0)return;const i=t.hasCode("union")&&t.errors.length===0?t:new be({code:"intersection",errors:r.hasCode("intersection")?[...r.errors,t]:[r,t]},this.ctx),s=this.indexOf(r);this.mutable[s===-1?this.length:s]=i,this.byPath[t.propString]=i,this.addAncestorPaths(t)}else this.byPath[t.propString]=t,this.addAncestorPaths(t),this.mutable.push(t);this.count++}addAncestorPaths(t){for(const r of t.path.stringifyAncestors())this.byAncestorPath[r]=w(this.byAncestorPath[r],t)}}class ao extends Error{constructor(t){var n=(...ju)=>(super(...ju),a(this,"name","TraversalError"),this);t.length===1?n(t.summary):n(`
`+t.map(r=>`  • ${co(r)}`).join(`
`)),Object.defineProperty(this,"arkErrors",{value:t,enumerable:!1})}}const co=e=>e.toString().split(`
`).join(`
  `);class ue{constructor(n,t){a(this,"path",[]);a(this,"errors",new ee(this));a(this,"root");a(this,"config");a(this,"queuedMorphs",[]);a(this,"branches",[]);a(this,"seen",{});this.root=n,this.config=t}get data(){let n=this.root;for(const t of this.path)n=n==null?void 0:n[t];return n}get propString(){return Ce(this.path)}reject(n){return this.error(n),!1}mustBe(n){return this.error(n),!1}error(n){const t=typeof n=="object"?n.code?n:{...n,code:"predicate"}:{code:"predicate",expected:n};return this.errorFromContext(t)}hasError(){return this.currentErrorCount!==0}get currentBranch(){return this.branches.at(-1)}queueMorphs(n){const t={path:new Nr(...this.path),morphs:n};this.currentBranch?this.currentBranch.queuedMorphs.push(t):this.queuedMorphs.push(t)}finalize(n){return this.queuedMorphs.length&&(typeof this.root=="object"&&this.root!==null&&this.config.clone&&(this.root=this.config.clone(this.root)),this.applyQueuedMorphs()),this.hasError()?n?n(this.errors):this.errors:this.root}get currentErrorCount(){return this.currentBranch?this.currentBranch.error?1:0:this.errors.count}get failFast(){return this.branches.length!==0}pushBranch(){this.branches.push({error:void 0,queuedMorphs:[]})}popBranch(){return this.branches.pop()}get external(){return this}errorFromNodeContext(n){return this.errorFromContext(n)}errorFromContext(n){const t=new be(n,this);return this.currentBranch?this.currentBranch.error=t:this.errors.add(t),t}applyQueuedMorphs(){for(;this.queuedMorphs.length;){const n=this.queuedMorphs;this.queuedMorphs=[];for(const{path:t,morphs:r}of n)this.errors.affectsPath(t)||this.applyMorphsAtPath(t,r)}}applyMorphsAtPath(n,t){const r=n.at(-1);let i;if(r!==void 0){i=this.root;for(let s=0;s<n.length-1;s++)i=i[n[s]]}this.path=[...n];for(const s of t){const o=P(s),c=s(i===void 0?this.root:i[r],this);if(c instanceof be){this.errors.add(c);break}if(c instanceof ee){o||this.errors.merge(c);break}i===void 0?this.root=c:i[r]=c,this.applyQueuedMorphs()}}}const H=(e,n,t)=>{if(!t)return n();t.path.push(e);const r=n();return t.path.pop(),r};class Dr extends $e{constructor(t,r){var s;super((o,c,l=this.onFail)=>c?(this.traverseApply(o,c),c.hasError()?c.errors:c.data):this.rootApply(o,l),{attach:t});a(this,"attachments");a(this,"$");a(this,"onFail");a(this,"includesTransform");a(this,"includesContextualPredicate");a(this,"isCyclic");a(this,"allowsRequiresContext");a(this,"rootApplyStrategy");a(this,"contextFreeMorph");a(this,"rootApply");a(this,"referencesById");a(this,"shallowReferences");a(this,"flatRefs");a(this,"flatMorphs");a(this,"allows");a(this,"compiledMeta",ho(this.metaJson));a(this,"precedence",He(this.kind));a(this,"precompilation");a(this,"assert",(t,r)=>this(t,r,i=>i.throw()));this.attachments=t,this.$=r,this.onFail=this.meta.onFail??this.$.resolvedConfig.onFail,this.includesTransform=this.hasKind("morph")||this.hasKind("structure")&&this.structuralMorph!==void 0,this.includesContextualPredicate=this.hasKind("predicate")&&this.inner.predicate.length!==1,this.isCyclic=this.kind==="alias",this.referencesById={[this.id]:this},this.shallowReferences=this.hasKind("structure")?[this,...this.children]:this.children.reduce((o,c)=>fo(o,c.shallowReferences),[this]);const i=this.isStructural();this.flatRefs=[],this.flatMorphs=[];for(let o=0;o<this.children.length;o++){if(this.includesTransform||(this.includesTransform=this.children[o].includesTransform),this.includesContextualPredicate||(this.includesContextualPredicate=this.children[o].includesContextualPredicate),this.isCyclic||(this.isCyclic=this.children[o].isCyclic),!i){const c=this.children[o].flatRefs;for(let l=0;l<c.length;l++){const u=c[l];if(!this.flatRefs.some(d=>Br(d,u))){this.flatRefs.push(u);for(const d of u.node.branches)(d.hasKind("morph")||d.hasKind("intersection")&&((s=d.structure)==null?void 0:s.structuralMorph)!==void 0)&&this.flatMorphs.push({path:u.path,propString:u.propString,node:d})}}}Object.assign(this.referencesById,this.children[o].referencesById)}this.flatRefs.sort((o,c)=>o.path.length>c.path.length?1:o.path.length<c.path.length?-1:o.propString>c.propString?1:o.propString<c.propString||o.node.expression<c.node.expression?-1:1),this.allowsRequiresContext=this.includesContextualPredicate||this.isCyclic,this.rootApplyStrategy=!this.allowsRequiresContext&&this.flatMorphs.length===0?this.shallowMorphs.length===0?"allows":this.shallowMorphs.every(o=>o.length===1||o.name==="$arkStructuralMorph")?this.hasKind("union")?this.branches.some(o=>o.shallowMorphs.length>1)?"contextual":"branchedOptimistic":this.shallowMorphs.length>1?"contextual":"optimistic":"contextual":"contextual",this.rootApply=this.createRootApply(),this.allows=this.allowsRequiresContext?o=>this.traverseAllows(o,new ue(o,this.$.resolvedConfig)):o=>this.traverseAllows(o)}get shallowMorphs(){return[]}createRootApply(){switch(this.rootApplyStrategy){case"allows":return(r,i)=>{if(this.allows(r))return r;const s=new ue(r,this.$.resolvedConfig);return this.traverseApply(r,s),s.finalize(i)};case"contextual":return(r,i)=>{const s=new ue(r,this.$.resolvedConfig);return this.traverseApply(r,s),s.finalize(i)};case"optimistic":this.contextFreeMorph=this.shallowMorphs[0];const t=this.$.resolvedConfig.clone;return(r,i)=>{if(this.allows(r))return this.contextFreeMorph(t&&(typeof r=="object"&&r!==null||typeof r=="function")?t(r):r);const s=new ue(r,this.$.resolvedConfig);return this.traverseApply(r,s),s.finalize(i)};case"branchedOptimistic":return this.createBranchedOptimisticRootApply();default:return this.rootApplyStrategy,M(`Unexpected rootApplyStrategy ${this.rootApplyStrategy}`)}}cacheGetter(t,r){return Object.defineProperty(this,t,{value:r}),r}get description(){var t;return this.cacheGetter("description",((t=this.meta)==null?void 0:t.description)??this.$.resolvedConfig[this.kind].description(this))}get references(){return Object.values(this.referencesById)}traverse(t,r){return this(t,r,null)}get in(){return this.cacheGetter("in",this.getIo("in"))}get out(){return this.cacheGetter("out",this.getIo("out"))}getIo(t){if(!this.includesTransform)return this;const r={};for(const[i,s]of this.innerEntries){const o=this.impl.keys[i];if(o.reduceIo)o.reduceIo(t,r,s);else if(o.child){const c=s;r[i]=B(c)?c.map(l=>l[t]):c[t]}else r[i]=s}return this.$.node(this.kind,r)}toJSON(){return this.json}toString(){return`Type<${this.expression}>`}equals(t){const r=P(t)?t:this.$.parseDefinition(t);return this.innerHash===r.innerHash}ifEquals(t){return this.equals(t)?this:void 0}hasKind(t){return this.kind===t}assertHasKind(t){return this.kind!==t&&me(`${this.kind} node was not of asserted kind ${t}`),this}hasKindIn(...t){return t.includes(this.kind)}assertHasKindIn(...t){return te(t,this.kind)||me(`${this.kind} node was not one of asserted kinds ${t}`),this}isBasis(){return te(to,this.kind)}isConstraint(){return te(Vt,this.kind)}isStructural(){return te(rt,this.kind)}isRefinement(){return te(Rr,this.kind)}isRoot(){return te(it,this.kind)}isUnknown(){return this.hasKind("intersection")&&this.children.length===0}isNever(){return this.hasKind("union")&&this.children.length===0}hasUnit(t){return this.hasKind("unit")&&this.allows(t)}hasOpenIntersection(){return this.impl.intersectionIsOpen}get nestableExpression(){return this.expression}select(t){const r=we.normalize(t);return this._select(r)}_select(t){let r=we.applyBoundary[t.boundary??"references"](this);return t.kind&&(r=r.filter(i=>i.kind===t.kind)),t.where&&(r=r.filter(t.where)),we.applyMethod[t.method??"filter"](r,this,t)}transform(t,r){return this._transform(t,this._createTransformContext(r))}_createTransformContext(t){return{root:this,selected:void 0,seen:{},path:[],parseOptions:{prereduced:(t==null?void 0:t.prereduced)??!1},undeclaredKeyHandling:void 0,...t}}_transform(t,r){var p;const i=r.bindScope??this.$;if(r.seen[this.id])return this.$.lazilyResolve(r.seen[this.id]);if(((p=r.shouldTransform)==null?void 0:p.call(r,this,r))===!1)return this;let s;r.seen[this.id]=()=>s,this.hasKind("structure")&&this.undeclared!==r.undeclaredKeyHandling&&(r={...r,undeclaredKeyHandling:this.undeclared});const o=N(this.inner,($,y)=>{if(!this.impl.keys[$].child)return[$,y];const v=y;if(!B(v)){const D=v._transform(t,r);return D?[$,D]:[]}if(v.length===0)return[$,y];const E=v.flatMap(D=>D._transform(t,r)??[]);return E.length?[$,E]:[]});delete r.seen[this.id];const c=Object.assign(o,{meta:this.meta}),l=r.selected&&!r.selected.includes(this)?c:t(this.kind,c,r);if(l===null)return null;if(P(l))return s=l;const u=Object.keys(l);return(u.length===0||u.length===1&&u[0]==="meta")&&!Re(this.inner)?null:(this.kind==="required"||this.kind==="optional"||this.kind==="index")&&!("value"in l)?r.undeclaredKeyHandling?{...l,value:f.intrinsic.unknown}:null:(this.kind==="morph"&&(l.in??(l.in=f.intrinsic.unknown)),s=i.node(this.kind,l,r.parseOptions))}configureReferences(t,r="references"){const i=we.normalize(r),s=typeof t=="string"?(u,d)=>({...d,meta:{...d.meta,description:t}}):typeof t=="function"?(u,d)=>({...d,meta:t(d.meta)}):(u,d)=>({...d,meta:{...d.meta,...t}});if(i.boundary==="self")return this.$.node(this.kind,s(this.kind,{...this.inner,meta:this.meta}));const o=this._select(i),c=o&&Me(o),l=i.boundary==="child"?(u,d)=>d.root.children.includes(u):i.boundary==="shallow"?u=>u.kind!=="structure":()=>!0;return this.$.finalize(this.transform(s,{shouldTransform:l,selected:c}))}}const we={applyBoundary:{self:e=>[e],child:e=>[...e.children],shallow:e=>[...e.shallowReferences],references:e=>[...e.references]},applyMethod:{filter:e=>e,assertFilter:(e,n,t)=>(e.length===0&&me(ln(n,t)),e),find:e=>e[0],assertFind:(e,n,t)=>(e.length===0&&me(ln(n,t)),e[0])},normalize:e=>typeof e=="function"?{boundary:"references",method:"filter",where:e}:typeof e=="string"?T(e,we.applyBoundary)?{method:"filter",boundary:e}:{boundary:"references",method:"filter",kind:e}:{boundary:"references",method:"filter",...e}},ln=(e,n)=>`${e} had no references matching ${k(n)}.`,lo=e=>Ce(e,{stringifyNonKey:n=>n.expression}),uo=/"(\$ark\.[^"]+)"/g,ho=e=>JSON.stringify(e).replaceAll(uo,"$1"),X=(e,n)=>({path:e,node:n,propString:lo(e)}),Br=(e,n)=>e.propString===n.propString&&e.node.equals(n.node),un=(e,n)=>ie(e,n,{isEqual:Br}),fo=(e,n)=>ie(e,n,{isEqual:(t,r)=>t.equals(r)});class m extends Array{static init(n,t,r,i){return new m({kind:n,l:t,r,path:(i==null?void 0:i.path)??[],optional:(i==null?void 0:i.optional)??!1})}add(n,t,r,i){return this.push({kind:n,l:t,r,path:(i==null?void 0:i.path)??[],optional:(i==null?void 0:i.optional)??!1}),this}get summary(){return this.describeReasons()}describeReasons(){if(this.length===1){const{path:n,l:t,r}=this[0],i=Ce(n);return Er(`Intersection${i&&` at ${i}`} of ${dn(t,r)}`)}return`The following intersections result in unsatisfiable types:
• ${this.map(({path:n,l:t,r})=>`${n}: ${dn(t,r)}`).join(`
• `)}`}throw(){return h(this.describeReasons())}invert(){const n=this.map(t=>({...t,l:t.r,r:t.l}));return n instanceof m?n:new m(...n)}withPrefixKey(n,t){return this.map(r=>({...r,path:[n,...r.path],optional:r.optional||t==="optional"}))}toNeverIfDisjoint(){return f.intrinsic.never}}const dn=(e,n)=>`${Ot(e)} and ${Ot(n)}`,Ot=e=>P(e)?e.expression:B(e)?e.map(Ot).join(" | ")||"never":String(e),Er=e=>`${e} results in an unsatisfiable type`,ce={},W=(e,n,t)=>C(e,n,{$:t,invert:!1,pipe:!1}),Mt=(e,n,t)=>C(e,n,{$:t,invert:!1,pipe:!0}),C=(e,n,t)=>{const r=t.pipe?"|>":"&",i=`${e.hash}${r}${n.hash}`;if(ce[i]!==void 0)return ce[i];if(!t.pipe){const c=`${n.hash}${r}${e.hash}`;if(ce[c]!==void 0){const l=ce[c],u=l instanceof m?l.invert():l;return ce[i]=u,u}}const s=!t.pipe||!e.includesTransform&&!n.includesTransform;if(s&&e.equals(n))return e;let o=s?Rt(e,n,t):e.hasKindIn(...it)?po(e,n,t):Rt(e,n,t);return P(o)&&(e.equals(o)?o=e:n.equals(o)&&(o=n)),ce[i]=o,o},Rt=(e,n,t)=>{const r=e.precedence<n.precedence?e.kind:n.kind,i=e.impl.intersections[n.kind]??n.impl.intersections[e.kind];if(i===void 0)return null;if(r===e.kind)return i(e,n,t);{let s=i(n,e,{...t,invert:!t.invert});return s instanceof m&&(s=s.invert()),s}},po=(e,n,t)=>e.includesTransform||n.includesTransform?t.invert?hn(n,e,t):hn(e,n,t):Rt(e,n,t),hn=(e,n,t)=>e.distribute(r=>mo(r,n,t),r=>{const i=r.filter(P);if(i.length===0)return m.init("union",e.branches,n.branches);if(i.length<e.branches.length||!e.branches.every((o,c)=>o.in.equals(i[c].in)))return t.$.parseSchema(i);if(i.length===1)return i[0];const s={branches:i};return t.$.parseSchema(s)}),mo=(e,n,t)=>{if(e.hasKind("morph")){const i=[...e.morphs];if(e.lastMorphIfNode){const s=C(e.lastMorphIfNode,n,t);if(s instanceof m)return s;i[i.length-1]=s}else i.push(n);return t.$.node("morph",{morphs:i,in:e.inner.in})}if(n.hasKind("morph")){const i=C(e,n.in,t);return i instanceof m?i:t.$.node("morph",{morphs:[n],in:i})}return t.$.node("morph",{morphs:[n],in:e})};class xe extends Dr{constructor(t,r){super(t,r);a(this,"impliedSiblings");Object.defineProperty(this,G,{value:"constraint",enumerable:!1})}intersect(t){return W(this,t,this.$)}}class ot extends xe{constructor(){super(...arguments);a(this,"traverseApply",(t,r)=>{this.traverseAllows(t,r)||r.errorFromNodeContext(this.errorContext)})}compile(t){t.traversalKind==="Allows"?t.return(this.compiledCondition):t.if(this.compiledNegation,()=>t.line(`${t.ctx}.errorFromNodeContext(${this.compiledErrorContext})`))}get errorContext(){return{code:this.kind,description:this.description,meta:this.meta,...this.inner}}get compiledErrorContext(){return st(this.errorContext)}}const L=e=>(n,t)=>{if(B(n)){if(n.length===0)return;const i=n.map(s=>t.$.node(e,s));return e==="predicate"?i:i.sort((s,o)=>s.hash<o.hash?-1:1)}const r=t.$.node(e,n);return r.hasOpenIntersection()?[r]:r},We=e=>{const n=e.r.shift();if(!n){let r=e.l.length===0&&e.kind==="structure"?f.intrinsic.unknown.internal:e.ctx.$.node(e.kind,Object.assign(e.baseInner,go(e.l)),{prereduced:!0});for(const i of e.roots){if(r instanceof m)return r;r=C(i,r,e.ctx)}return r}let t=!1;for(let r=0;r<e.l.length;r++){const i=C(e.l[r],n,e.ctx);if(i!==null){if(i instanceof m)return i;if(t){if(!e.l.includes(i))return M(`Unexpectedly encountered multiple distinct intersection results for refinement ${i}`)}else{if(i.isRoot())return e.roots.push(i),e.l.splice(r),We(e);e.l[r]=i,t=!0}}}if(t||e.l.push(n),e.kind==="intersection"&&n.impliedSiblings)for(const r of n.impliedSiblings)ie(e.r,r);return We(e)},Ze=e=>Object.entries(e).flatMap(([t,r])=>t in Kr?r:[]).sort((t,r)=>t.precedence<r.precedence?-1:t.precedence>r.precedence?1:t.kind==="predicate"&&r.kind==="predicate"?0:t.hash<r.hash?-1:1),go=e=>{const n={};for(const t of e)if(t.hasOpenIntersection())n[t.kind]=w(n[t.kind],t);else{if(n[t.kind])return M(`Unexpected intersection of closed refinements of kind ${t.kind}`);n[t.kind]=t}return n},yo=(...e)=>h(bo(...e)),bo=(e,n,t)=>{const r=t.hasKind("morph")?"a morph":t.isUnknown()?"unknown":t.exclude(n).defaultShortDescription;return`${Ss(e)} operand must be ${n.description} (was ${r})`},$o=(e,n,t)=>new Ye(e,n,t,t,null);class Pr extends $e{}var nr,rr;class Ye extends(rr=$e,nr=G,rr){constructor(t,r,i,s,o){super((...c)=>{const l=N(this.names,(u,d)=>{const p=this.arg$.parse(c[u]);return p.extends(this.constraints[u])||h(xo(d,this.constraints[u].expression,p.expression)),[d,p]});if(this.defIsLazy()){const u=this.bodyDef(l);return this.$.parse(u)}return this.$.parse(r,{args:l})});a(this,nr,"generic");a(this,"paramDefs");a(this,"bodyDef");a(this,"$");a(this,"arg$");a(this,"baseInstantiation");a(this,"hkt");a(this,"description");this.paramDefs=t,this.bodyDef=r,this.$=i,this.arg$=s,this.hkt=o,this.description=o?new o().description??`a generic type for ${o.constructor.name}`:"a generic type",this.baseInstantiation=this(...this.constraints)}defIsLazy(){return this.bodyDef instanceof Pr}cacheGetter(t,r){return Object.defineProperty(this,t,{value:r}),r}get json(){return this.cacheGetter("json",{params:this.params.map(t=>t[1].isUnknown()?t[0]:[t[0],t[1].json]),body:Gs(this.bodyDef)})}get params(){return this.cacheGetter("params",this.paramDefs.map(t=>typeof t=="string"?[t,f.intrinsic.unknown]:[t[0],this.$.parse(t[1])]))}get names(){return this.cacheGetter("names",this.params.map(t=>t[0]))}get constraints(){return this.cacheGetter("constraints",this.params.map(t=>t[1]))}get internal(){return this}get referencesById(){return this.baseInstantiation.internal.referencesById}get references(){return this.baseInstantiation.internal.references}}const xo=(e,n,t)=>`${e} must be assignable to ${n} (was ${t})`,vo=S({kind:"predicate",hasAssociatedError:!0,collapsibleKey:"predicate",keys:{predicate:{}},normalize:e=>typeof e=="function"?{predicate:e}:e,defaults:{description:e=>`valid according to ${e.predicate.name||"an anonymous predicate"}`},intersectionIsOpen:!0,intersections:{predicate:()=>null}});class ko extends xe{constructor(){super(...arguments);a(this,"serializedPredicate",z(this.predicate));a(this,"compiledCondition",`${this.serializedPredicate}(data, ctx)`);a(this,"compiledNegation",`!${this.compiledCondition}`);a(this,"impliedBasis",null);a(this,"expression",this.serializedPredicate);a(this,"traverseAllows",this.predicate);a(this,"errorContext",{code:"predicate",description:this.description,meta:this.meta});a(this,"compiledErrorContext",st(this.errorContext));a(this,"traverseApply",(t,r)=>{!this.predicate(t,r.external)&&!r.hasError()&&r.errorFromNodeContext(this.errorContext)})}compile(t){if(t.traversalKind==="Allows"){t.return(this.compiledCondition);return}t.if(`${this.compiledNegation} && !ctx.hasError()`,()=>t.line(`ctx.errorFromNodeContext(${this.compiledErrorContext})`))}reduceJsonSchema(t,r){return r.fallback.predicate({code:"predicate",base:t,predicate:this.predicate})}}const zr={implementation:vo,Node:ko},wo=S({kind:"divisor",collapsibleKey:"rule",keys:{rule:{parse:e=>Number.isInteger(e)?e:h(Ao(e))}},normalize:e=>typeof e=="number"?{rule:e}:e,hasAssociatedError:!0,defaults:{description:e=>e.rule===1?"an integer":e.rule===2?"even":`a multiple of ${e.rule}`},intersections:{divisor:(e,n,t)=>t.$.node("divisor",{rule:Math.abs(e.rule*n.rule/Io(e.rule,n.rule))})},obviatesBasisDescription:!0});class No extends ot{constructor(){super(...arguments);a(this,"traverseAllows",t=>t%this.rule===0);a(this,"compiledCondition",`data % ${this.rule} === 0`);a(this,"compiledNegation",`data % ${this.rule} !== 0`);a(this,"impliedBasis",f.intrinsic.number.internal);a(this,"expression",`% ${this.rule}`)}reduceJsonSchema(t){return t.type="integer",this.rule===1||(t.multipleOf=this.rule),t}}const Lr={implementation:wo,Node:No},Ao=e=>`divisor must be an integer (was ${e})`,Io=(e,n)=>{let t,r=e,i=n;for(;i!==0;)t=i,i=r%i,r=t;return r};class ve extends ot{constructor(){super(...arguments);a(this,"boundOperandKind",Ro[this.kind]);a(this,"compiledActual",this.boundOperandKind==="value"?"data":this.boundOperandKind==="length"?"data.length":"data.valueOf()");a(this,"comparator",Ko(this.kind,this.exclusive));a(this,"numericLimit",this.rule.valueOf());a(this,"expression",`${this.comparator} ${this.rule}`);a(this,"compiledCondition",`${this.compiledActual} ${this.comparator} ${this.numericLimit}`);a(this,"compiledNegation",`${this.compiledActual} ${So[this.comparator]} ${this.numericLimit}`);a(this,"stringLimit",this.boundOperandKind==="date"?qo(this.numericLimit):`${this.numericLimit}`);a(this,"limitKind",this.comparator[0]==="<"?"upper":"lower")}isStricterThan(t){return(this.limitKind==="upper"?this.numericLimit<t.numericLimit:this.numericLimit>t.numericLimit)||this.numericLimit===t.numericLimit&&this.exclusive===!0&&!t.exclusive}overlapsRange(t){return!(this.isStricterThan(t)||this.numericLimit===t.numericLimit&&(this.exclusive||t.exclusive))}overlapIsUnit(t){return this.numericLimit===t.numericLimit&&!this.exclusive&&!t.exclusive}}const So={"<":">=","<=":">",">":"<=",">=":"<"},Oo={min:"max",minLength:"maxLength",after:"before"},jr={parse:e=>e||void 0},Fr=e=>n=>{if(typeof n=="number")return{rule:n};const{exclusive:t,...r}=n;return t?{...r,rule:e==="minLength"?r.rule+1:r.rule-1}:r},Ur=e=>n=>{if(typeof n=="number"||typeof n=="string"||n instanceof Date)return{rule:n};const{exclusive:t,...r}=n;if(!t)return r;const i=typeof r.rule=="number"?r.rule:typeof r.rule=="string"?new Date(r.rule).valueOf():r.rule.valueOf();return t?{...r,rule:e==="after"?i+1:i-1}:r},Tr=e=>typeof e=="string"||typeof e=="number"?new Date(e):e,Mo=(e,n)=>`${e} bound must be a positive integer (was ${n})`,Gt=e=>n=>((!Number.isInteger(n)||n<0)&&h(Mo(e,n)),n),Ro={min:"value",max:"value",minLength:"length",maxLength:"length",after:"date",before:"date"},Ko=(e,n)=>`${T(e,Oo)?">":"<"}${n?"":"="}`,qo=e=>typeof e=="string"?e:new Date(e).toLocaleString(),Co=e=>`Bounded expression ${e} must be exactly one of number, string, Array, or Date`,Do=S({kind:"after",collapsibleKey:"rule",hasAssociatedError:!0,keys:{rule:{parse:Tr,serialize:e=>e.toISOString()}},normalize:Ur("after"),defaults:{description:e=>`${e.collapsibleLimitString} or later`,actual:qe},intersections:{after:(e,n)=>e.isStricterThan(n)?e:n}});class Bo extends ve{constructor(){super(...arguments);a(this,"impliedBasis",f.intrinsic.Date.internal);a(this,"collapsibleLimitString",qe(this.rule));a(this,"traverseAllows",t=>t>=this.rule)}reduceJsonSchema(t,r){return r.fallback.date({code:"date",base:t,after:this.rule})}}const Jr={implementation:Do,Node:Bo},Eo=S({kind:"before",collapsibleKey:"rule",hasAssociatedError:!0,keys:{rule:{parse:Tr,serialize:e=>e.toISOString()}},normalize:Ur("before"),defaults:{description:e=>`${e.collapsibleLimitString} or earlier`,actual:qe},intersections:{before:(e,n)=>e.isStricterThan(n)?e:n,after:(e,n,t)=>e.overlapsRange(n)?e.overlapIsUnit(n)?t.$.node("unit",{unit:e.rule}):null:m.init("range",e,n)}});class Po extends ve{constructor(){super(...arguments);a(this,"collapsibleLimitString",qe(this.rule));a(this,"traverseAllows",t=>t<=this.rule);a(this,"impliedBasis",f.intrinsic.Date.internal)}reduceJsonSchema(t,r){return r.fallback.date({code:"date",base:t,before:this.rule})}}const Vr={implementation:Eo,Node:Po},zo=S({kind:"exactLength",collapsibleKey:"rule",keys:{rule:{parse:Gt("exactLength")}},normalize:e=>typeof e=="number"?{rule:e}:e,hasAssociatedError:!0,defaults:{description:e=>`exactly length ${e.rule}`,actual:e=>`${e.length}`},intersections:{exactLength:(e,n,t)=>m.init("unit",t.$.node("unit",{unit:e.rule}),t.$.node("unit",{unit:n.rule}),{path:["length"]}),minLength:(e,n)=>e.rule>=n.rule?e:m.init("range",e,n),maxLength:(e,n)=>e.rule<=n.rule?e:m.init("range",e,n)}});class Lo extends ot{constructor(){super(...arguments);a(this,"traverseAllows",t=>t.length===this.rule);a(this,"compiledCondition",`data.length === ${this.rule}`);a(this,"compiledNegation",`data.length !== ${this.rule}`);a(this,"impliedBasis",f.intrinsic.lengthBoundable.internal);a(this,"expression",`== ${this.rule}`)}reduceJsonSchema(t){switch(t.type){case"string":return t.minLength=this.rule,t.maxLength=this.rule,t;case"array":return t.minItems=this.rule,t.maxItems=this.rule,t;default:return R.throwInternalOperandError("exactLength",t)}}}const _r={implementation:zo,Node:Lo},jo=S({kind:"max",collapsibleKey:"rule",hasAssociatedError:!0,keys:{rule:{},exclusive:jr},normalize:e=>typeof e=="number"?{rule:e}:e,defaults:{description:e=>e.rule===0?e.exclusive?"negative":"non-positive":`${e.exclusive?"less than":"at most"} ${e.rule}`},intersections:{max:(e,n)=>e.isStricterThan(n)?e:n,min:(e,n,t)=>e.overlapsRange(n)?e.overlapIsUnit(n)?t.$.node("unit",{unit:e.rule}):null:m.init("range",e,n)},obviatesBasisDescription:!0});class Fo extends ve{constructor(){super(...arguments);a(this,"impliedBasis",f.intrinsic.number.internal);a(this,"traverseAllows",this.exclusive?t=>t<this.rule:t=>t<=this.rule)}reduceJsonSchema(t){return this.exclusive?t.exclusiveMaximum=this.rule:t.maximum=this.rule,t}}const Gr={implementation:jo,Node:Fo},Uo=S({kind:"maxLength",collapsibleKey:"rule",hasAssociatedError:!0,keys:{rule:{parse:Gt("maxLength")}},reduce:(e,n)=>e.rule===0?n.node("exactLength",e):void 0,normalize:Fr("maxLength"),defaults:{description:e=>`at most length ${e.rule}`,actual:e=>`${e.length}`},intersections:{maxLength:(e,n)=>e.isStricterThan(n)?e:n,minLength:(e,n,t)=>e.overlapsRange(n)?e.overlapIsUnit(n)?t.$.node("exactLength",{rule:e.rule}):null:m.init("range",e,n)}});class To extends ve{constructor(){super(...arguments);a(this,"impliedBasis",f.intrinsic.lengthBoundable.internal);a(this,"traverseAllows",t=>t.length<=this.rule)}reduceJsonSchema(t){switch(t.type){case"string":return t.maxLength=this.rule,t;case"array":return t.maxItems=this.rule,t;default:return R.throwInternalOperandError("maxLength",t)}}}const Hr={implementation:Uo,Node:To},Jo=S({kind:"min",collapsibleKey:"rule",hasAssociatedError:!0,keys:{rule:{},exclusive:jr},normalize:e=>typeof e=="number"?{rule:e}:e,defaults:{description:e=>e.rule===0?e.exclusive?"positive":"non-negative":`${e.exclusive?"more than":"at least"} ${e.rule}`},intersections:{min:(e,n)=>e.isStricterThan(n)?e:n},obviatesBasisDescription:!0});class Vo extends ve{constructor(){super(...arguments);a(this,"impliedBasis",f.intrinsic.number.internal);a(this,"traverseAllows",this.exclusive?t=>t>this.rule:t=>t>=this.rule)}reduceJsonSchema(t){return this.exclusive?t.exclusiveMinimum=this.rule:t.minimum=this.rule,t}}const Wr={implementation:Jo,Node:Vo},_o=S({kind:"minLength",collapsibleKey:"rule",hasAssociatedError:!0,keys:{rule:{parse:Gt("minLength")}},reduce:e=>e.rule===0?f.intrinsic.unknown:void 0,normalize:Fr("minLength"),defaults:{description:e=>e.rule===1?"non-empty":`at least length ${e.rule}`,actual:e=>e.length===0?"":`${e.length}`},intersections:{minLength:(e,n)=>e.isStricterThan(n)?e:n}});class Go extends ve{constructor(){super(...arguments);a(this,"impliedBasis",f.intrinsic.lengthBoundable.internal);a(this,"traverseAllows",t=>t.length>=this.rule)}reduceJsonSchema(t){switch(t.type){case"string":return t.minLength=this.rule,t;case"array":return t.minItems=this.rule,t;default:return R.throwInternalOperandError("minLength",t)}}}const Zr={implementation:_o,Node:Go},Ho={min:Wr.implementation,max:Gr.implementation,minLength:Zr.implementation,maxLength:Hr.implementation,exactLength:_r.implementation,after:Jr.implementation,before:Vr.implementation},Wo={min:Wr.Node,max:Gr.Node,minLength:Zr.Node,maxLength:Hr.Node,exactLength:_r.Node,after:Jr.Node,before:Vr.Node},Zo=S({kind:"pattern",collapsibleKey:"rule",keys:{rule:{},flags:{}},normalize:e=>typeof e=="string"?{rule:e}:e instanceof RegExp?e.flags?{rule:e.source,flags:e.flags}:{rule:e.source}:e,obviatesBasisDescription:!0,obviatesBasisExpression:!0,hasAssociatedError:!0,intersectionIsOpen:!0,defaults:{description:e=>`matched by ${e.rule}`},intersections:{pattern:()=>null}});class Yo extends ot{constructor(){super(...arguments);a(this,"instance",new RegExp(this.rule,this.flags));a(this,"expression",`${this.instance}`);a(this,"traverseAllows",this.instance.test.bind(this.instance));a(this,"compiledCondition",`${this.expression}.test(data)`);a(this,"compiledNegation",`!${this.compiledCondition}`);a(this,"impliedBasis",f.intrinsic.string.internal)}reduceJsonSchema(t,r){return t.pattern?r.fallback.patternIntersection({code:"patternIntersection",base:t,pattern:this.rule}):(t.pattern=this.rule,t)}}const Yr={implementation:Zo,Node:Yo},Je=(e,n)=>{const t=Qo(e);return n&&!n.includes(t)?h(`Root of kind ${t} should be one of ${n}`):t},Qo=e=>{if(g(e,"root"))return e.kind;if(typeof e=="string")return e[0]==="$"?"alias":e in _?"domain":"proto";if(typeof e=="function")return"proto";if(typeof e!="object"||e===null)return h(fn(e));if("morphs"in e)return"morph";if("branches"in e||B(e))return"union";if("unit"in e)return"unit";if("reference"in e)return"alias";const n=Object.keys(e);return n.length===0||n.some(t=>t in Kr)?"intersection":"proto"in e?"proto":"domain"in e?"domain":h(fn(e))},fn=e=>`${k(e)} is not a valid type schema`,Le={},Xo=e=>B(e)?e.map(n=>n.collapsibleJson):e.collapsibleJson,j={};f.nodesByRegisteredId=j;const Qr=e=>(Le[e]??(Le[e]=0),`${e}${++Le[e]}`),Xr=e=>{var u;const n=at[e.kind],t=((u=n.applyConfig)==null?void 0:u.call(n,e.def,e.$.resolvedConfig))??e.def,r={},{meta:i,...s}=t,o=i===void 0?{}:typeof i=="string"?{description:i}:i,c=hr(s).sort(([d],[p])=>Te(d)?Te(p)?He(d)-He(p):1:Te(p)||d<p?-1:1).filter(([d,p])=>{if(d.startsWith("meta.")){const $=d.slice(5);return o[$]=p,!1}return!0});for(const d of c){const p=d[0],$=n.keys[p];if(!$)return h(`Key ${p} is not valid on ${e.kind} schema`);const y=$.parse?$.parse(d[1],e):d[1];y!==V&&(y!==void 0||$.preserveUndefined)&&(r[p]=y)}if(n.reduce&&!e.prereduced){const d=n.reduce(r,e.$);if(d)return d instanceof m?d.throw():ta(d,o)}return Ht({id:e.id,kind:e.kind,inner:r,meta:o,$:e.$})},Ht=({id:e,kind:n,inner:t,meta:r,$:i,ignoreCache:s})=>{const o=at[n],c=hr(t),l=[];let u={};for(const[K,U]of c){const ke=o.keys[K],Qi=ke.serialize??(ke.child?Xo:se);if(u[K]=Qi(U),ke.child===!0){const ut=U;B(ut)?l.push(...ut):l.push(ut)}else typeof ke.child=="function"&&l.push(...ke.child(U))}o.finalizeInnerJson&&(u=o.finalizeInnerJson(u));let d={...u},p={};Re(r)||(p=N(r,(K,U)=>[K,K==="examples"?U:se(U)]),d.meta=je(p,"description",!0)),u=je(u,o.collapsibleKey,!1);const $=JSON.stringify({kind:n,...u});d=je(d,o.collapsibleKey,!1);const y=je(d,o.collapsibleKey,!0),v=JSON.stringify({kind:n,...d});if(i.nodesByHash[v]&&!s)return i.nodesByHash[v];const E={id:e,kind:n,impl:o,inner:t,innerEntries:c,innerJson:u,innerHash:$,meta:r,metaJson:p,json:d,hash:v,collapsibleJson:y,children:l};if(n!=="intersection")for(const K in t)K!=="in"&&K!=="out"&&(E[K]=t[K]);const D=new sc[n](E,i);return i.nodesByHash[v]=D},ea=(e,n)=>e.id===n?e:(P(j[n])&&M(`Unexpected attempt to overwrite node id ${n}`),Ht({id:n,kind:e.kind,inner:e.inner,meta:e.meta,$:e.$,ignoreCache:!0})),ta=(e,n,t)=>Ht({id:Qr(n.alias??e.kind),kind:e.kind,inner:e.inner,meta:n,$:e.$}),je=(e,n,t)=>{const r=Object.keys(e);if(r.length===1&&r[0]===n){const i=e[n];if(t||oe(i,"object")&&(Object.keys(i).length===1||Array.isArray(i)))return i}return e},Kt=(e,n,t)=>{if(e.key!==n.key)return null;const r=e.key;let i=C(e.value,n.value,t);const s=e.required||n.required?"required":"optional";if(i instanceof m)if(s==="optional")i=f.intrinsic.never.internal;else return i.withPrefixKey(e.key,e.required&&n.required?"required":"optional");if(s==="required")return t.$.node("required",{key:r,value:i});const o=e.hasDefault()?n.hasDefault()?e.default===n.default?e.default:h(ti(e.default,n.default)):e.default:n.hasDefault()?n.default:V;return t.$.node("optional",{key:r,value:i,default:o})};class ei extends xe{constructor(){super(...arguments);a(this,"required",this.kind==="required");a(this,"optional",this.kind==="optional");a(this,"impliedBasis",f.intrinsic.object.internal);a(this,"serializedKey",De(this.key));a(this,"compiledKey",typeof this.key=="string"?this.key:this.serializedKey);a(this,"flatRefs",w(this.value.flatRefs.map(t=>X([this.key,...t.path],t.node)),X([this.key],this.value)));a(this,"traverseAllows",(t,r)=>this.key in t?H(this.key,()=>this.value.traverseAllows(t[this.key],r),r):this.optional);a(this,"traverseApply",(t,r)=>{this.key in t?H(this.key,()=>this.value.traverseApply(t[this.key],r),r):this.hasKind("required")&&r.errorFromNodeContext(this.errorContext)})}_transform(t,r){r.path.push(this.key);const i=super._transform(t,r);return r.path.pop(),i}hasDefault(){return"default"in this.inner}compile(t){t.if(`${this.serializedKey} in data`,()=>t.traverseKey(this.serializedKey,`data${t.prop(this.key)}`,this.value)),this.hasKind("required")&&t.else(()=>t.traversalKind==="Apply"?t.line(`ctx.errorFromNodeContext(${this.compiledErrorContext})`):t.return(!1)),t.traversalKind==="Allows"&&t.return(!0)}}const ti=(e,n)=>`Invalid intersection of default values ${k(e)} & ${k(n)}`,na=S({kind:"optional",hasAssociatedError:!1,intersectionIsOpen:!0,keys:{key:{},value:{child:!0,parse:(e,n)=>n.$.parseSchema(e)},default:{preserveUndefined:!0}},normalize:e=>e,reduce:(e,n)=>{if(n.resolvedConfig.exactOptionalPropertyTypes===!1&&!e.value.allows(void 0))return n.node("optional",{...e,value:e.value.or(b.undefined)},{prereduced:!0})},defaults:{description:e=>`${e.compiledKey}?: ${e.value.description}`},intersections:{optional:Kt}});class ra extends ei{constructor(...t){super(...t);a(this,"expression",this.hasDefault()?`${this.compiledKey}: ${this.value.expression} = ${k(this.inner.default)}`:`${this.compiledKey}?: ${this.value.expression}`);a(this,"defaultValueMorph",ia(this));a(this,"defaultValueMorphRef",this.defaultValueMorph&&z(this.defaultValueMorph));"default"in this.inner&&Zt(this.value,this.inner.default,this.key)}get outProp(){if(!this.hasDefault())return this;const{default:t,...r}=this.inner;return this.cacheGetter("outProp",this.$.node("required",r,{prereduced:!0}))}}const Wt={implementation:na,Node:ra},ft={},ia=e=>{if(!e.hasDefault())return;const n=`{${e.compiledKey}: ${e.value.id} = ${se(e.default)}}`;return ft[n]??(ft[n]=ni(e.key,e.value,e.default))},ni=(e,n,t)=>{if(typeof t=="function")return n.includesTransform?(i,s)=>(H(e,()=>n(i[e]=t(),s),s),i):i=>(i[e]=t(),i);const r=n.includesTransform?n.assert(t):t;return oe(r,"object")?(i,s)=>(H(e,()=>n(i[e]=t,s),s),i):i=>(i[e]=r,i)},Zt=(e,n,t)=>{const r=tt(n);oe(n,"object")&&!r&&h(sa(t));const i=e.in(r?n():n);if(i instanceof ee){t===null&&h(`Default ${i.summary}`);const s=i.transform(o=>o.transform(c=>({...c,prefixPath:[t]})));h(`Default for ${s.summary}`)}return n},sa=e=>`Non-primitive default ${e===null?"":typeof e=="number"?`for value at [${e}] `:`for ${De(e)} `}must be specified as a function like () => ({my: 'object'})`;class Be extends Dr{constructor(t,r){super(t,r);a(this,"branches",this.hasKind("union")?this.inner.branches:[this]);a(this,"_keyof");a(this,"pipe",Object.assign(this._pipe.bind(this),{try:this.tryPipe.bind(this)}));Object.defineProperty(this,G,{value:"root",enumerable:!1})}get internal(){return this}get"~standard"(){return{vendor:"arktype",version:1,validate:t=>{const r=this(t);return r instanceof ee?r:{value:r}}}}as(){return this}brand(t){return t===""?h(oa):this}readonly(){return this}distribute(t,r){const i=this.branches.map(t);return(r==null?void 0:r(i))??i}get shortDescription(){return this.meta.description??this.defaultShortDescription}toJsonSchema(t={}){const r=Cr(this.$.resolvedConfig.toJsonSchema,t);r.useRefs||(r.useRefs=this.isCyclic);const i=typeof r.dialect=="string"?{$schema:r.dialect}:{};return Object.assign(i,this.toJsonSchemaRecurse(r)),r.useRefs&&(i.$defs=N(this.references,(s,o)=>o.isRoot()&&!o.alwaysExpandJsonSchema?[o.id,o.toResolvedJsonSchema(r)]:[])),i}toJsonSchemaRecurse(t){return t.useRefs&&!this.alwaysExpandJsonSchema?{$ref:`#/$defs/${this.id}`}:this.toResolvedJsonSchema(t)}get alwaysExpandJsonSchema(){return this.isBasis()||this.kind==="alias"||this.hasKind("union")&&this.isBoolean}toResolvedJsonSchema(t){const r=this.innerToJsonSchema(t);return Object.assign(r,this.metaJson)}intersect(t){const r=this.$.parseDefinition(t),i=this.rawIntersect(r);return i instanceof m?i:this.$.finalize(i)}rawIntersect(t){return W(this,t,this.$)}toNeverIfDisjoint(){return this}and(t){const r=this.intersect(t);return r instanceof m?r.throw():r}rawAnd(t){const r=this.rawIntersect(t);return r instanceof m?r.throw():r}or(t){const r=this.$.parseDefinition(t);return this.$.finalize(this.rawOr(r))}rawOr(t){const r=[...this.branches,...t.branches];return this.$.node("union",r)}map(t){return this.$.schema(this.applyStructuralOperation("map",[t]))}pick(...t){return this.$.schema(this.applyStructuralOperation("pick",t))}omit(...t){return this.$.schema(this.applyStructuralOperation("omit",t))}required(){return this.$.schema(this.applyStructuralOperation("required",[]))}partial(){return this.$.schema(this.applyStructuralOperation("partial",[]))}keyof(){if(this._keyof)return this._keyof;const t=this.applyStructuralOperation("keyof",[]).reduce((r,i)=>r.intersect(i).toNeverIfDisjoint(),f.intrinsic.unknown.internal);return t.branches.length===0&&h(Er(`keyof ${this.expression}`)),this._keyof=this.$.finalize(t)}get props(){return this.branches.length!==1?h(aa(this.expression)):[...this.applyStructuralOperation("props",[])[0]]}merge(t){const r=this.$.parseDefinition(t);return this.$.schema(r.distribute(i=>this.applyStructuralOperation("merge",[pn(i)??h(mn("merge",i.expression))])))}applyStructuralOperation(t,r){return this.distribute(i=>{if(i.equals(f.intrinsic.object)&&t!=="merge")return i;const s=pn(i);if(s||h(mn(t,i.expression)),t==="keyof")return s.keyof();if(t==="get")return s.get(...r);if(t==="props")return s.props;const o=t==="required"?"require":t==="partial"?"optionalize":t;return this.$.node("intersection",{...i.inner,structure:s[o](...r)})})}get(...t){return t[0]===void 0?this:this.$.schema(this.applyStructuralOperation("get",t))}extract(t){const r=this.$.parseDefinition(t);return this.$.schema(this.branches.filter(i=>i.extends(r)))}exclude(t){const r=this.$.parseDefinition(t);return this.$.schema(this.branches.filter(i=>!i.extends(r)))}array(){return this.$.schema(this.isUnknown()?{proto:Array}:{proto:Array,sequence:this},{prereduced:!0})}overlaps(t){return!(this.intersect(t)instanceof m)}extends(t){const r=this.intersect(t);return!(r instanceof m)&&this.equals(r)}ifExtends(t){return this.extends(t)?this:void 0}subsumes(t){return this.$.parseDefinition(t).extends(this)}configure(t,r="shallow"){return this.configureReferences(t,r)}describe(t,r="shallow"){return this.configure({description:t},r)}optional(){return[this,"?"]}default(t){return Zt(this,t,null),[this,"=",t]}from(t){return this.assert(t)}_pipe(...t){const r=t.reduce((i,s)=>i.rawPipeOnce(s),this);return this.$.finalize(r)}tryPipe(...t){const r=t.reduce((i,s)=>i.rawPipeOnce(g(s,"root")?s:(o,c)=>{try{return s(o,c)}catch(l){return c.error({code:"predicate",predicate:s,actual:`aborted due to error:
    ${l}
`})}}),this);return this.$.finalize(r)}to(t){return this.$.finalize(this.toNode(this.$.parseDefinition(t)))}toNode(t){const r=Mt(this,t,this.$);return r instanceof m?r.throw():r}rawPipeOnce(t){return g(t,"root")?this.toNode(t):this.distribute(r=>r.hasKind("morph")?this.$.node("morph",{in:r.inner.in,morphs:[...r.morphs,t]}):this.$.node("morph",{in:r,morphs:[t]}),this.$.parseSchema)}narrow(t){return this.constrainOut("predicate",t)}constrain(t,r){return this._constrain("root",t,r)}constrainIn(t,r){return this._constrain("in",t,r)}constrainOut(t,r){return this._constrain("out",t,r)}_constrain(t,r,i){const s=this.$.node(r,i);if(s.isRoot())return s.isUnknown()?this:M(`Unexpected constraint node ${s}`);const o=t==="root"?this:this[t];if(o.hasKind("morph")||s.impliedBasis&&!o.extends(s.impliedBasis))return yo(r,s.impliedBasis,this);const c=this.$.node("intersection",{[s.kind]:s}),l=t==="out"?Mt(this,c,this.$):W(this,c,this.$);return l instanceof m&&l.throw(),this.$.finalize(l)}onUndeclaredKey(t){const r=typeof t=="string"?t:t.rule,i=typeof t=="string"?!1:t.deep;return this.$.finalize(this.transform((s,o)=>s==="structure"?r==="ignore"?ds(o,{undeclared:1}):{...o,undeclared:r}:o,i?void 0:{shouldTransform:s=>!te(rt,s.kind)}))}hasEqualMorphs(t){return!this.includesTransform&&!t.includesTransform?!0:!(!pe(this.shallowMorphs,t.shallowMorphs)||!pe(this.flatMorphs,t.flatMorphs,{isEqual:(r,i)=>{var s,o;return r.propString===i.propString&&(r.node.hasKind("morph")&&i.node.hasKind("morph")?r.node.hasEqualMorphs(i.node):r.node.hasKind("intersection")&&i.node.hasKind("intersection")?((s=r.node.structure)==null?void 0:s.structuralMorphRef)===((o=i.node.structure)==null?void 0:o.structuralMorphRef):!1)}}))}onDeepUndeclaredKey(t){return this.onUndeclaredKey({rule:t,deep:!0})}filter(t){return this.constrainIn("predicate",t)}divisibleBy(t){return this.constrain("divisor",t)}matching(t){return this.constrain("pattern",t)}atLeast(t){return this.constrain("min",t)}atMost(t){return this.constrain("max",t)}moreThan(t){return this.constrain("min",le(t))}lessThan(t){return this.constrain("max",le(t))}atLeastLength(t){return this.constrain("minLength",t)}atMostLength(t){return this.constrain("maxLength",t)}moreThanLength(t){return this.constrain("minLength",le(t))}lessThanLength(t){return this.constrain("maxLength",le(t))}exactlyLength(t){return this.constrain("exactLength",t)}atOrAfter(t){return this.constrain("after",t)}atOrBefore(t){return this.constrain("before",t)}laterThan(t){return this.constrain("after",le(t))}earlierThan(t){return this.constrain("before",le(t))}}const oa="Expected a non-empty brand name after #",le=e=>typeof e=="object"&&!(e instanceof Date)?{...e,exclusive:!0}:{rule:e,exclusive:!0},Fe=(e,n)=>g(n,"root")?g(e,"root")?e.extends(n):n.allows(e):g(e,"root")?e.hasUnit(n):n===e,pn=e=>{var n;return e.hasKind("morph")?null:e.hasKind("intersection")?e.inner.structure??(((n=e.basis)==null?void 0:n.domain)==="object"?e.$.bindReference(f.intrinsic.emptyStructure):null):e.isBasis()&&e.domain==="object"?e.$.bindReference(f.intrinsic.emptyStructure):null},aa=e=>`Props cannot be extracted from a union. Use .distribute to extract props from each branch instead. Received:
${e}`,mn=(e,n)=>`${e} operand must be an object (was ${n})`,Ee=(e,n)=>N(_t(e),(t,r)=>[r,n]),ca=e=>typeof e=="string"?{reference:e}:e,gn=e=>e instanceof m?f.intrinsic.never.internal:e,la=S({kind:"alias",hasAssociatedError:!1,collapsibleKey:"reference",keys:{reference:{serialize:e=>e.startsWith("$")?e:`$ark.${e}`},resolve:{}},normalize:ca,defaults:{description:e=>e.reference},intersections:{alias:(e,n,t)=>t.$.lazilyResolve(()=>gn(C(e.resolution,n.resolution,t)),`${e.reference}${t.pipe?"=>":"&"}${n.reference}`),...Ee("alias",(e,n,t)=>n.isUnknown()?e:n.isNever()?n:n.isBasis()&&!n.overlaps(f.intrinsic.object)?m.init("assignability",f.intrinsic.object,n):t.$.lazilyResolve(()=>gn(C(e.resolution,n,t)),`${e.reference}${t.pipe?"=>":"&"}${n.id}`))}});class ua extends Be{constructor(){super(...arguments);a(this,"expression",this.reference);a(this,"structure");a(this,"traverseAllows",(t,r)=>{const i=r.seen[this.reference];return i!=null&&i.includes(t)?!0:(r.seen[this.reference]=w(i,t),this.resolution.traverseAllows(t,r))});a(this,"traverseApply",(t,r)=>{const i=r.seen[this.reference];i!=null&&i.includes(t)||(r.seen[this.reference]=w(i,t),this.resolution.traverseApply(t,r))})}get resolution(){const t=this._resolve();return j[this.id]=t}_resolve(){if(this.resolve)return this.resolve();if(this.reference[0]==="$")return this.$.resolveRoot(this.reference.slice(1));const t=this.reference;let r=j[t];const i=[];for(;g(r,"context");){if(i.includes(r.id))return h(da(r.id,i));i.push(r.id),r=j[r.id]}return g(r,"root")?r:M(`Unexpected resolution for reference ${this.reference}
Seen: [${i.join("->")}] 
Resolution: ${k(r)}`)}get resolutionId(){if(this.reference.includes("&")||this.reference.includes("=>"))return this.resolution.id;if(this.reference[0]!=="$")return this.reference;const t=this.reference.slice(1),r=this.$.resolutions[t];return typeof r=="string"?r:g(r,"root")?r.id:M(`Unexpected resolution for reference ${this.reference}: ${k(r)}`)}get defaultShortDescription(){return _.object}innerToJsonSchema(t){return this.resolution.toJsonSchemaRecurse(t)}compile(t){const r=this.resolutionId;t.if(`ctx.seen.${r} && ctx.seen.${r}.includes(data)`,()=>t.return(!0)),t.if(`!ctx.seen.${r}`,()=>t.line(`ctx.seen.${r} = []`)),t.line(`ctx.seen.${r}.push(data)`),t.return(t.invoke(r))}}const da=(e,n)=>`Alias '${e}' has a shallow resolution cycle: ${[...n,e].join("->")}`,Yt={implementation:la,Node:ua};class Qt extends Be{constructor(){super(...arguments);a(this,"traverseApply",(t,r)=>{this.traverseAllows(t,r)||r.errorFromNodeContext(this.errorContext)})}get errorContext(){return{code:this.kind,description:this.description,meta:this.meta,...this.inner}}get compiledErrorContext(){return st(this.errorContext)}compile(t){t.traversalKind==="Allows"?t.return(this.compiledCondition):t.if(this.compiledNegation,()=>t.line(`${t.ctx}.errorFromNodeContext(${this.compiledErrorContext})`))}}const ha=S({kind:"domain",hasAssociatedError:!0,collapsibleKey:"domain",keys:{domain:{},numberAllowsNaN:{}},normalize:e=>typeof e=="string"?{domain:e}:jt(e,"numberAllowsNaN")&&e.domain!=="number"?h(Xt.writeBadAllowNanMessage(e.domain)):e,applyConfig:(e,n)=>e.numberAllowsNaN===void 0&&e.domain==="number"&&n.numberAllowsNaN?{...e,numberAllowsNaN:!0}:e,defaults:{description:e=>_[e.domain],actual:e=>Number.isNaN(e)?"NaN":_[F(e)]},intersections:{domain:(e,n)=>e.domain==="number"&&n.domain==="number"?e.numberAllowsNaN?n:e:m.init("domain",e,n)}});class fa extends Qt{constructor(){super(...arguments);a(this,"requiresNaNCheck",this.domain==="number"&&!this.numberAllowsNaN);a(this,"traverseAllows",this.requiresNaNCheck?t=>typeof t=="number"&&!Number.isNaN(t):t=>F(t)===this.domain);a(this,"compiledCondition",this.domain==="object"?'((typeof data === "object" && data !== null) || typeof data === "function")':`typeof data === "${this.domain}"${this.requiresNaNCheck?" && !Number.isNaN(data)":""}`);a(this,"compiledNegation",this.domain==="object"?'((typeof data !== "object" || data === null) && typeof data !== "function")':`typeof data !== "${this.domain}"${this.requiresNaNCheck?" || Number.isNaN(data)":""}`);a(this,"expression",this.numberAllowsNaN?"number | NaN":this.domain)}get nestableExpression(){return this.numberAllowsNaN?`(${this.expression})`:this.expression}get defaultShortDescription(){return _[this.domain]}innerToJsonSchema(t){return this.domain==="bigint"||this.domain==="symbol"?t.fallback.domain({code:"domain",base:{},domain:this.domain}):{type:this.domain}}}const Xt={implementation:ha,Node:fa,writeBadAllowNanMessage:e=>`numberAllowsNaN may only be specified with domain "number" (was ${e})`},pa=S({kind:"intersection",hasAssociatedError:!0,normalize:e=>{if(P(e))return e;const{structure:n,...t}=e,r=!!n,i=n??{},s=N(t,(o,c)=>T(o,ro)?(r&&h(`Flattened structure key ${o} cannot be specified alongside a root 'structure' key.`),i[o]=c,[]):[o,c]);return(g(i,"constraint")||!Re(i))&&(s.structure=i),s},finalizeInnerJson:({structure:e,...n})=>oe(e,"object")?{...e,...n}:n,keys:{domain:{child:!0,parse:(e,n)=>n.$.node("domain",e)},proto:{child:!0,parse:(e,n)=>n.$.node("proto",e)},structure:{child:!0,parse:(e,n)=>n.$.node("structure",e),serialize:e=>{var o;if(!((o=e.sequence)!=null&&o.minLength))return e.collapsibleJson;const{sequence:n,...t}=e.collapsibleJson,{minVariadicLength:r,...i}=n,s=i.variadic&&Object.keys(i).length===1?i.variadic:i;return{...t,sequence:s}}},divisor:{child:!0,parse:L("divisor")},max:{child:!0,parse:L("max")},min:{child:!0,parse:L("min")},maxLength:{child:!0,parse:L("maxLength")},minLength:{child:!0,parse:L("minLength")},exactLength:{child:!0,parse:L("exactLength")},before:{child:!0,parse:L("before")},after:{child:!0,parse:L("after")},pattern:{child:!0,parse:L("pattern")},predicate:{child:!0,parse:L("predicate")}},reduce:(e,n)=>yn({},e,{$:n,invert:!1,pipe:!1}),defaults:{description:e=>{if(e.children.length===0)return"unknown";if(e.structure)return e.structure.description;const n=[];if(e.basis&&!e.refinements.some(t=>t.impl.obviatesBasisDescription)&&n.push(e.basis.description),e.refinements.length){const t=e.refinements.toSorted((r,i)=>r.kind==="min"&&i.kind==="max"?-1:0).map(r=>r.description);n.push(...t)}return e.inner.predicate&&n.push(...e.inner.predicate.map(t=>t.description)),n.join(" and ")},expected:e=>`  ◦ ${e.errors.map(n=>n.expected).join(`
  ◦ `)}`,problem:e=>`(${e.actual}) must be...
${e.expected}`},intersections:{intersection:(e,n,t)=>yn(e.inner,n.inner,t),...Ee("intersection",(e,n,t)=>{var l;if(e.children.length===0)return n;const{domain:r,proto:i,...s}=e.inner,o=i??r,c=o?C(o,n,t):n;return c instanceof m?c:(l=e==null?void 0:e.basis)!=null&&l.equals(c)?e:e.$.node("intersection",{...s,[c.kind]:c},{prereduced:!0})})}});class ma extends Be{constructor(){super(...arguments);a(this,"basis",this.inner.domain??this.inner.proto??null);a(this,"refinements",this.children.filter(t=>t.isRefinement()));a(this,"structure",this.inner.structure);a(this,"expression",ga(this));a(this,"traverseAllows",(t,r)=>this.children.every(i=>i.traverseAllows(t,r)));a(this,"traverseApply",(t,r)=>{const i=r.currentErrorCount;if(!(this.basis&&(this.basis.traverseApply(t,r),r.currentErrorCount>i))){if(this.refinements.length){for(let s=0;s<this.refinements.length-1;s++)if(this.refinements[s].traverseApply(t,r),r.failFast&&r.currentErrorCount>i)return;if(this.refinements.at(-1).traverseApply(t,r),r.currentErrorCount>i)return}if(!(this.structure&&(this.structure.traverseApply(t,r),r.currentErrorCount>i))&&this.inner.predicate){for(let s=0;s<this.inner.predicate.length-1;s++)if(this.inner.predicate[s].traverseApply(t,r),r.failFast&&r.currentErrorCount>i)return;this.inner.predicate.at(-1).traverseApply(t,r)}}})}get shallowMorphs(){var t;return(t=this.inner.structure)!=null&&t.structuralMorph?[this.inner.structure.structuralMorph]:[]}get defaultShortDescription(){var t;return((t=this.basis)==null?void 0:t.defaultShortDescription)??"present"}innerToJsonSchema(t){return this.children.reduce((r,i)=>i.isBasis()?i.toJsonSchemaRecurse(t):i.reduceJsonSchema(r,t),{})}compile(t){if(t.traversalKind==="Allows"){for(const r of this.children)t.check(r);t.return(!0);return}if(t.initializeErrorCount(),this.basis&&(t.check(this.basis),this.children.length>1&&t.returnIfFail()),this.refinements.length){for(let r=0;r<this.refinements.length-1;r++)t.check(this.refinements[r]),t.returnIfFailFast();t.check(this.refinements.at(-1)),(this.structure||this.inner.predicate)&&t.returnIfFail()}if(this.structure&&(t.check(this.structure),this.inner.predicate&&t.returnIfFail()),this.inner.predicate){for(let r=0;r<this.inner.predicate.length-1;r++)t.check(this.inner.predicate[r]),t.returnIfFail();t.check(this.inner.predicate.at(-1))}}}const ri={implementation:pa,Node:ma},ga=e=>{var t;let n=((t=e.structure)==null?void 0:t.expression)||`${e.basis&&!e.refinements.some(r=>r.impl.obviatesBasisExpression)?e.basis.nestableExpression+" ":""}${e.refinements.map(r=>r.expression).join(" & ")}`||"unknown";return n==="Array == 0"&&(n="[]"),n},yn=(e,n,t)=>{const r={},i=e.proto??e.domain,s=n.proto??n.domain,o=i?s?C(i,s,t):i:s;return o instanceof m?o:(o&&(r[o.kind]=o),We({kind:"intersection",baseInner:r,l:Ze(e),r:Ze(n),roots:[],ctx:t}))},ya=S({kind:"morph",hasAssociatedError:!1,keys:{in:{child:!0,parse:(e,n)=>n.$.parseSchema(e)},morphs:{parse:Me,serialize:e=>e.map(n=>g(n,"root")?n.json:z(n))},declaredIn:{child:!1,serialize:e=>e.json},declaredOut:{child:!1,serialize:e=>e.json}},normalize:e=>e,defaults:{description:e=>{var n;return`a morph from ${e.in.description} to ${((n=e.out)==null?void 0:n.description)??"unknown"}`}},intersections:{morph:(e,n,t)=>{if(!e.hasEqualMorphs(n))return h($a(e.expression,n.expression));const r=C(e.in,n.in,t);if(r instanceof m)return r;const i={morphs:e.morphs};if(e.declaredIn||n.declaredIn){const s=C(e.in,n.in,t);if(s instanceof m)return s.throw();i.declaredIn=s}if(e.declaredOut||n.declaredOut){const s=C(e.out,n.out,t);if(s instanceof m)return s.throw();i.declaredOut=s}return r.distribute(s=>t.$.node("morph",{...i,in:s}),t.$.parseSchema)},...Ee("morph",(e,n,t)=>{const r=e.inner.in?C(e.inner.in,n,t):n;return r instanceof m?r:r.equals(e.inner.in)?e:t.$.node("morph",{...e.inner,in:r})})}});class ba extends Be{constructor(){super(...arguments);a(this,"serializedMorphs",this.morphs.map(z));a(this,"compiledMorphs",`[${this.serializedMorphs}]`);a(this,"lastMorph",this.inner.morphs.at(-1));a(this,"lastMorphIfNode",g(this.lastMorph,"root")?this.lastMorph:void 0);a(this,"introspectableIn",this.inner.in);a(this,"introspectableOut",this.lastMorphIfNode?Object.assign(this.referencesById,this.lastMorphIfNode.referencesById)&&this.lastMorphIfNode.out:void 0);a(this,"expression",`(In: ${this.in.expression}) => ${this.lastMorphIfNode?"To":"Out"}<${this.out.expression}>`);a(this,"traverseAllows",(t,r)=>!this.introspectableIn||this.introspectableIn.traverseAllows(t,r));a(this,"traverseApply",(t,r)=>{this.introspectableIn&&this.introspectableIn.traverseApply(t,r),r.queueMorphs(this.morphs)})}get shallowMorphs(){var t;return Array.isArray((t=this.inner.in)==null?void 0:t.shallowMorphs)?[...this.inner.in.shallowMorphs,...this.morphs]:this.morphs}get in(){var t;return this.declaredIn??((t=this.inner.in)==null?void 0:t.in)??f.intrinsic.unknown.internal}get out(){return this.declaredOut??this.introspectableOut??f.intrinsic.unknown.internal}declareIn(t){return this.$.node("morph",{...this.inner,declaredIn:t})}declareOut(t){return this.$.node("morph",{...this.inner,declaredOut:t})}get defaultShortDescription(){return this.in.meta.description??this.in.defaultShortDescription}innerToJsonSchema(t){var r;return t.fallback.morph({code:"morph",base:this.in.toJsonSchemaRecurse(t),out:((r=this.introspectableOut)==null?void 0:r.toJsonSchemaRecurse(t))??null})}compile(t){if(t.traversalKind==="Allows"){if(!this.introspectableIn)return;t.return(t.invoke(this.introspectableIn));return}this.introspectableIn&&t.line(t.invoke(this.introspectableIn)),t.line(`ctx.queueMorphs(${this.compiledMorphs})`)}hasEqualMorphs(t){return pe(this.morphs,t.morphs,{isEqual:(r,i)=>r===i||g(r,"root")&&g(i,"root")&&r.equals(i)})}}const ii={implementation:ya,Node:ba},$a=(e,n)=>`The intersection of distinct morphs at a single path is indeterminate:
Left: ${e}
Right: ${n}`,xa=S({kind:"proto",hasAssociatedError:!0,collapsibleKey:"proto",keys:{proto:{serialize:e=>Ut(e)??se(e)},dateAllowsInvalid:{}},normalize:e=>{const n=typeof e=="string"?{proto:ge[e]}:typeof e=="function"?P(e)?e:{proto:e}:typeof e.proto=="string"?{...e,proto:ge[e.proto]}:e;return typeof n.proto!="function"&&h(Qe.writeInvalidSchemaMessage(n.proto)),jt(n,"dateAllowsInvalid")&&n.proto!==Date&&h(Qe.writeBadInvalidDateMessage(n.proto)),n},applyConfig:(e,n)=>e.dateAllowsInvalid===void 0&&e.proto===Date&&n.dateAllowsInvalid?{...e,dateAllowsInvalid:!0}:e,defaults:{description:e=>e.builtinName?$s[e.builtinName]:`an instance of ${e.proto.name}`,actual:e=>e instanceof Date&&e.toString()==="Invalid Date"?"an invalid Date":vt(e)},intersections:{proto:(e,n)=>e.proto===Date&&n.proto===Date?e.dateAllowsInvalid?n:e:sn(e.proto,n.proto)?e:sn(n.proto,e.proto)?n:m.init("proto",e,n),domain:(e,n)=>n.domain==="object"?e:m.init("domain",f.intrinsic.object.internal,n)}});class va extends Qt{constructor(){super(...arguments);a(this,"builtinName",Ut(this.proto));a(this,"serializedConstructor",this.json.proto);a(this,"requiresInvalidDateCheck",this.proto===Date&&!this.dateAllowsInvalid);a(this,"traverseAllows",this.requiresInvalidDateCheck?t=>t instanceof Date&&t.toString()!=="Invalid Date":t=>t instanceof this.proto);a(this,"compiledCondition",`data instanceof ${this.serializedConstructor}${this.requiresInvalidDateCheck?' && data.toString() !== "Invalid Date"':""}`);a(this,"compiledNegation",`!(${this.compiledCondition})`);a(this,"expression",this.dateAllowsInvalid?"Date | InvalidDate":this.proto.name);a(this,"domain","object")}innerToJsonSchema(t){var r,i;switch(this.builtinName){case"Array":return{type:"array"};case"Date":return((i=(r=t.fallback).date)==null?void 0:i.call(r,{code:"date",base:{}}))??t.fallback.proto({code:"proto",base:{},proto:this.proto});default:return t.fallback.proto({code:"proto",base:{},proto:this.proto})}}get nestableExpression(){return this.dateAllowsInvalid?`(${this.expression})`:this.expression}get defaultShortDescription(){return this.description}}const Qe={implementation:xa,Node:va,writeBadInvalidDateMessage:e=>`dateAllowsInvalid may only be specified with constructor Date (was ${e.name})`,writeInvalidSchemaMessage:e=>`instanceOf operand must be a function (was ${F(e)})`},ka=S({kind:"union",hasAssociatedError:!0,collapsibleKey:"branches",keys:{ordered:{},branches:{child:!0,parse:(e,n)=>{const t=[];for(const r of e){const i=g(r,"root")?r.branches:n.$.parseSchema(r).branches;for(const s of i)if(s.hasKind("morph")){const o=t.findIndex(c=>c.hasKind("morph")&&c.hasEqualMorphs(s));if(o===-1)t.push(s);else{const c=t[o];t[o]=n.$.node("morph",{...c.inner,in:c.in.rawOr(s.in)})}}else t.push(s)}return n.def.ordered||t.sort((r,i)=>r.hash<i.hash?-1:1),t}}},normalize:e=>B(e)?{branches:e}:e,reduce:(e,n)=>{const t=Ca(e);if(t.length===1)return t[0];if(t.length!==e.branches.length)return n.node("union",{...e,branches:t},{prereduced:!0})},defaults:{description:e=>e.distribute(n=>n.description,he),expected:e=>{const n=is(e.errors,"propString"),t=Object.entries(n).map(([r,i])=>{const s=[];for(const l of i)ie(s,l.expected);const o=he(s),c=i.every(l=>l.actual===i[0].actual)?i[0].actual:k(i[0].data);return`${r&&`${r} `}must be ${o}${c&&` (was ${c})`}`});return he(t)},problem:e=>e.expected,message:e=>e.problem},intersections:{union:(e,n,t)=>{if(e.isNever!==n.isNever)return m.init("presence",e,n);let r;return e.ordered?(n.ordered&&h(Ba(e.expression,n.expression)),r=pt(n.branches,e.branches,t),r instanceof m&&r.invert()):r=pt(e.branches,n.branches,t),r instanceof m?r:t.$.parseSchema(e.ordered||n.ordered?{branches:r,ordered:!0}:{branches:r})},...Ee("union",(e,n,t)=>{const r=pt(e.branches,[n],t);return r instanceof m?r:r.length===1?r[0]:t.$.parseSchema(e.ordered?{branches:r,ordered:!0}:{branches:r})})}});class wa extends Be{constructor(){super(...arguments);a(this,"isBoolean",this.branches.length===2&&this.branches[0].hasUnit(!1)&&this.branches[1].hasUnit(!0));a(this,"unitBranches",this.branches.filter(t=>t.in.hasKind("unit")));a(this,"discriminant",this.discriminate());a(this,"discriminantJson",this.discriminant?Ra(this.discriminant):null);a(this,"expression",this.distribute(t=>t.nestableExpression,qa));a(this,"traverseAllows",(t,r)=>this.branches.some(i=>i.traverseAllows(t,r)));a(this,"traverseApply",(t,r)=>{const i=[];for(let s=0;s<this.branches.length;s++){if(r.pushBranch(),this.branches[s].traverseApply(t,r),!r.hasError())return this.branches[s].includesTransform?r.queuedMorphs.push(...r.popBranch().queuedMorphs):r.popBranch();i.push(r.popBranch().error)}r.errorFromNodeContext({code:"union",errors:i,meta:this.meta})});a(this,"traverseOptimistic",t=>{for(let r=0;r<this.branches.length;r++){const i=this.branches[r];if(i.traverseAllows(t))return i.contextFreeMorph?i.contextFreeMorph(t):t}return V})}get branchGroups(){const t=[];let r=-1;for(const i of this.branches){if(i.hasKind("unit")&&i.domain==="boolean"){r===-1?(r=t.length,t.push(i)):t[r]=f.intrinsic.boolean;continue}t.push(i)}return t}createBranchedOptimisticRootApply(){return(t,r)=>{const i=this.traverseOptimistic(t);if(i!==V)return i;const s=new ue(t,this.$.resolvedConfig);return this.traverseApply(t,s),s.finalize(r)}}get shallowMorphs(){return this.branches.reduce((t,r)=>ie(t,r.shallowMorphs),[])}get defaultShortDescription(){return this.distribute(t=>t.defaultShortDescription,he)}innerToJsonSchema(t){if(this.branchGroups.length===1&&this.branchGroups[0].equals(f.intrinsic.boolean))return{type:"boolean"};const r=this.branchGroups.map(i=>i.toJsonSchemaRecurse(t));return r.every(i=>Object.keys(i).length===1&&jt(i,"const"))?{enum:r.map(i=>i.const)}:{anyOf:r}}compile(t){if(!this.discriminant||this.unitBranches.length===this.branches.length&&this.branches.length===2)return this.compileIndiscriminable(t);let r=this.discriminant.optionallyChainedPropString;this.discriminant.kind==="domain"&&(r=`typeof ${r} === "object" ? ${r} === null ? "null" : "object" : typeof ${r} === "function" ? "object" : typeof ${r}`);const i=this.discriminant.cases,s=Object.keys(i),{optimistic:o}=t;if(t.optimistic=!1,t.block(`switch(${r})`,()=>{for(const p in i){const $=i[p],y=p==="default"?p:`case ${p}`;t.line(`${y}: return ${$===!0?o?t.data:$:o?`${t.invoke($)} ? ${$.contextFreeMorph?`${z($.contextFreeMorph)}(${t.data})`:t.data} : "${V}"`:t.invoke($)}`)}return t}),t.traversalKind==="Allows"){t.return(o?`"${V}"`:!1);return}const c=he(this.discriminant.kind==="domain"?s.map(p=>{const $=p.slice(1,-1);return $==="function"?_.object:_[$]}):s),l=this.discriminant.path.map(p=>typeof p=="symbol"?z(p):JSON.stringify(p)),u=JSON.stringify(c),d=this.discriminant.kind==="domain"?`${Oa}[${r}]`:`${Ma}(${r})`;t.line(`ctx.errorFromNodeContext({
	code: "predicate",
	expected: ${u},
	actual: ${d},
	relativePath: [${l}],
	meta: ${this.compiledMeta}
})`)}compileIndiscriminable(t){if(t.traversalKind==="Apply"){t.const("errors","[]");for(const r of this.branches)t.line("ctx.pushBranch()").line(t.invoke(r)).if("!ctx.hasError()",()=>t.return(r.includesTransform?"ctx.queuedMorphs.push(...ctx.popBranch().queuedMorphs)":"ctx.popBranch()")).line("errors.push(ctx.popBranch().error)");t.line(`ctx.errorFromNodeContext({ code: "union", errors, meta: ${this.compiledMeta} })`)}else{const{optimistic:r}=t;t.optimistic=!1;for(const i of this.branches)t.if(`${t.invoke(i)}`,()=>t.return(r?i.contextFreeMorph?`${z(i.contextFreeMorph)}(${t.data})`:t.data:!0));t.return(r?`"${V}"`:!1)}}get nestableExpression(){return this.isBoolean?"boolean":`(${this.expression})`}discriminate(){var o,c;if(this.branches.length<2||this.isCyclic)return null;if(this.unitBranches.length===this.branches.length){const l=N(this.unitBranches,(u,d)=>[`${d.in.serializedValue}`,d.hasKind("morph")?d:!0]);return{kind:"unit",path:[],optionallyChainedPropString:"data",cases:l}}const t=[];for(let l=0;l<this.branches.length-1;l++){const u=this.branches[l];for(let d=l+1;d<this.branches.length;d++){const p=this.branches[d],$=W(u.in,p.in,u.$);if($ instanceof m)for(const y of $){if(!y.kind||y.optional)continue;let v,E;if(y.kind==="domain"){const K=y.l,U=y.r;v=`"${typeof K=="string"?K:K.domain}"`,E=`"${typeof U=="string"?U:U.domain}"`}else if(y.kind==="unit")v=y.l.serializedValue,E=y.r.serializedValue;else continue;const D=t.find(K=>pe(K.path,y.path)&&K.kind===y.kind);D?(D.cases[v]?D.cases[v].branchIndices=ie(D.cases[v].branchIndices,l):(o=D.cases)[v]??(o[v]={branchIndices:[l],condition:y.l}),D.cases[E]?D.cases[E].branchIndices=ie(D.cases[E].branchIndices,d):(c=D.cases)[E]??(c[E]={branchIndices:[d],condition:y.r})):t.push({kind:y.kind,cases:{[v]:{branchIndices:[l],condition:y.l},[E]:{branchIndices:[d],condition:y.r}},path:y.path})}}}const r=this.ordered?Ia(t,this.branches):t;if(!r.length)return null;const i=Na(r,this),s={};for(const l in i.best.cases){const u=Aa(i,l);if(u===null){s[l]=!0;continue}if(u.length===this.branches.length)return null;this.ordered&&u.sort(($,y)=>$.originalIndex-y.originalIndex);const d=u.map($=>$.branch),p=d.length===1?d[0]:this.$.node("union",this.ordered?{branches:d,ordered:!0}:d);Object.assign(this.referencesById,p.referencesById),s[l]=p}if(i.defaultEntries.length){const l=i.defaultEntries.map(u=>u.branch);s.default=this.$.node("union",this.ordered?{branches:l,ordered:!0}:l,{prereduced:!0}),Object.assign(this.referencesById,s.default.referencesById)}return Object.assign(i.location,{cases:s})}}const Na=(e,n)=>{const t=e.sort((s,o)=>Object.keys(o.cases).length-Object.keys(s.cases).length)[0],r={kind:t.kind,path:t.path,optionallyChainedPropString:si(t.path)},i=n.branches.map((s,o)=>({originalIndex:o,branch:s}));return{best:t,location:r,defaultEntries:i,node:n}},Aa=(e,n)=>{const t=e.best.cases[n],r=Sa(t.condition,e.location.path,e.node.$);let i=[];const s=[];for(let o=0;o<e.defaultEntries.length;o++){const c=e.defaultEntries[o];if(t.branchIndices.includes(c.originalIndex)){const l=bn(e.node.branches[c.originalIndex],e.location);l===null?i=null:i==null||i.push({originalIndex:c.originalIndex,branch:l})}else if(c.branch.hasKind("alias")&&r.hasKind("domain")&&r.domain==="object")i==null||i.push(c);else{if(c.branch.in.overlaps(r)){const l=bn(c.branch,e.location);i==null||i.push({originalIndex:c.originalIndex,branch:l})}s.push(c)}}return e.defaultEntries=s,i},Ia=(e,n)=>e.filter(r=>{const i=Object.values(r.cases).map(s=>s.branchIndices);for(let s=0;s<i.length-1;s++){const o=i[s];for(let c=s+1;c<i.length;c++){const l=i[c];for(const u of o)for(const d of l)if(u>d&&n[u].overlaps(n[d]))return!1}}return!0}),Sa=(e,n,t)=>{let r=e==="undefined"?t.node("unit",{unit:void 0}):e==="null"?t.node("unit",{unit:null}):e==="boolean"?t.units([!0,!1]):e;for(let i=n.length-1;i>=0;i--){const s=n[i];r=t.node("intersection",typeof s=="number"?{proto:"Array",sequence:[...ns(s).map(o=>({})),r]}:{domain:"object",required:[{key:s,value:r}]})}return r},si=e=>e.reduce((n,t)=>n+Sr(t,!0),"data"),Oa=z(ss),Ma=z(k),oi={implementation:ka,Node:wa},Ra=e=>({kind:e.kind,path:e.path.map(n=>typeof n=="string"?n:De(n)),cases:N(e.cases,(n,t)=>[n,t===!0?t:t.hasKind("union")&&t.discriminantJson?t.discriminantJson:t.json])}),Ka={delimiter:" | ",finalDelimiter:" | "},qa=e=>he(e,Ka),he=(e,n)=>{const t=(n==null?void 0:n.delimiter)??", ",r=(n==null?void 0:n.finalDelimiter)??" or ";if(e.length===0)return"never";if(e.length===1)return e[0];if(e.length===2&&e[0]==="false"&&e[1]==="true"||e[0]==="true"&&e[1]==="false")return"boolean";const i={},s=e.filter(c=>i[c]?!1:i[c]=!0),o=s.pop();return`${s.join(t)}${s.length?r:""}${o}`},pt=(e,n,t)=>{const r=n.map(()=>[]);for(let s=0;s<e.length;s++){let o={};for(let c=0;c<n.length;c++){if(r[c]===null)continue;if(e[s].equals(n[c])){r[c]=null,o={};break}const l=C(e[s],n[c],t);if(!(l instanceof m)){if(l.equals(e[s])){r[c].push(e[s]),o={};break}l.equals(n[c])?r[c]=null:o[c]=l}}for(const c in o)r[c][s]=o[c]}const i=r.flatMap((s,o)=>(s==null?void 0:s.flatMap(c=>c.branches))??n[o]);return i.length===0?m.init("union",e,n):i},Ca=({branches:e,ordered:n})=>{if(e.length<2)return e;const t=e.map(()=>!0);for(let r=0;r<e.length;r++)for(let i=r+1;i<e.length&&t[r]&&t[i];i++){if(e[r].equals(e[i])){t[i]=!1;continue}const s=W(e[r].in,e[i].in,e[0].$);s instanceof m||(n||Da(e[r],e[i]),s.equals(e[r].in)?t[r]=!!n:s.equals(e[i].in)&&(t[i]=!1))}return e.filter((r,i)=>t[i])},Da=(e,n)=>{!e.includesTransform&&!n.includesTransform||(pe(e.shallowMorphs,n.shallowMorphs)||h($n(e.expression,n.expression)),pe(e.flatMorphs,n.flatMorphs,{isEqual:(t,r)=>{var i,s;return t.propString===r.propString&&(t.node.hasKind("morph")&&r.node.hasKind("morph")?t.node.hasEqualMorphs(r.node):t.node.hasKind("intersection")&&r.node.hasKind("intersection")?((i=t.node.structure)==null?void 0:i.structuralMorphRef)===((s=r.node.structure)==null?void 0:s.structuralMorphRef):!1)}})||h($n(e.expression,n.expression)))},bn=(e,n)=>e.transform((t,r)=>t==="domain"||t==="unit"?null:r,{shouldTransform:(t,r)=>{const i=si(r.path);return n.optionallyChainedPropString.startsWith(i)?t.hasKind("domain")&&t.domain==="object"||(t.hasKind("domain")||n.kind==="unit")&&i===n.optionallyChainedPropString?!0:t.children.length!==0&&t.kind!=="index":!1}}),$n=(e,n)=>`An unordered union of a type including a morph and a type with overlapping input is indeterminate:
Left: ${e}
Right: ${n}`,Ba=(e,n)=>`The intersection of two ordered unions is indeterminate:
Left: ${e}
Right: ${n}`,Ea=S({kind:"unit",hasAssociatedError:!0,keys:{unit:{preserveUndefined:!0,serialize:e=>e instanceof Date?e.toISOString():se(e)}},normalize:e=>e,defaults:{description:e=>k(e.unit),problem:({expected:e,actual:n})=>`${e===n?`must be reference equal to ${e} (serialized to the same value)`:`must be ${e} (was ${n})`}`},intersections:{unit:(e,n)=>m.init("unit",e,n),...Ee("unit",(e,n)=>{if(n.allows(e.unit))return e;const t=n.hasKind("intersection")?n.basis:n;if(t){const r=t.hasKind("domain")?t:f.intrinsic.object;if(e.domain!==r.domain){const i=e.domain==="undefined"||e.domain==="null"||e.domain==="boolean"?e.domain:f.intrinsic[e.domain];return m.init("domain",i,r)}}return m.init("assignability",e,n.hasKind("intersection")?n.children.find(r=>!r.allows(e.unit)):n)})}});class Pa extends Qt{constructor(){super(...arguments);a(this,"compiledValue",this.json.unit);a(this,"serializedValue",typeof this.unit=="string"||this.unit instanceof Date?JSON.stringify(this.compiledValue):`${this.compiledValue}`);a(this,"compiledCondition",xn(this.unit,this.serializedValue));a(this,"compiledNegation",xn(this.unit,this.serializedValue,"negated"));a(this,"expression",k(this.unit));a(this,"domain",F(this.unit));a(this,"traverseAllows",this.unit instanceof Date?t=>t instanceof Date&&t.toISOString()===this.compiledValue:Number.isNaN(this.unit)?t=>Number.isNaN(t):t=>t===this.unit)}get defaultShortDescription(){return this.domain==="object"?_.object:this.description}innerToJsonSchema(t){return this.unit===null?{type:"null"}:f.intrinsic.jsonPrimitive.allows(this.unit)?{const:this.unit}:t.fallback.unit({code:"unit",base:{},unit:this.unit})}}const ai={implementation:Ea,Node:Pa},xn=(e,n,t)=>{if(e instanceof Date){const r=`data instanceof Date && data.toISOString() === ${n}`;return t?`!(${r})`:r}return Number.isNaN(e)?`${t?"!":""}Number.isNaN(data)`:`data ${t?"!":"="}== ${n}`},za=S({kind:"index",hasAssociatedError:!1,intersectionIsOpen:!0,keys:{signature:{child:!0,parse:(e,n)=>{const t=n.$.parseSchema(e);if(!t.extends(f.intrinsic.key))return h(Fa(t.expression));const r=t.branches.filter(i=>i.hasKind("unit"));return r.length?h(ja(r.map(i=>k(i.unit)))):t}},value:{child:!0,parse:(e,n)=>n.$.parseSchema(e)}},normalize:e=>e,defaults:{description:e=>`[${e.signature.expression}]: ${e.value.description}`},intersections:{index:(e,n,t)=>{if(e.signature.equals(n.signature)){const r=C(e.value,n.value,t),i=r instanceof m?f.intrinsic.never.internal:r;return t.$.node("index",{signature:e.signature,value:i})}return e.signature.extends(n.signature)&&e.value.subsumes(n.value)?n:n.signature.extends(e.signature)&&n.value.subsumes(e.value)?e:null}}});class La extends xe{constructor(){super(...arguments);a(this,"impliedBasis",f.intrinsic.object.internal);a(this,"expression",`[${this.signature.expression}]: ${this.value.expression}`);a(this,"flatRefs",w(this.value.flatRefs.map(t=>X([this.signature,...t.path],t.node)),X([this.signature],this.value)));a(this,"traverseAllows",(t,r)=>Ve(t).every(i=>this.signature.traverseAllows(i[0],r)?H(i[0],()=>this.value.traverseAllows(i[1],r),r):!0));a(this,"traverseApply",(t,r)=>{for(const i of Ve(t))this.signature.traverseAllows(i[0],r)&&H(i[0],()=>this.value.traverseApply(i[1],r),r)})}_transform(t,r){r.path.push(this.signature);const i=super._transform(t,r);return r.path.pop(),i}compile(){}}const ci={implementation:za,Node:La},ja=e=>`Index keys ${e.join(", ")} should be specified as named props.`,Fa=e=>`Indexed key definition '${e}' must be a string or symbol`,Ua=S({kind:"required",hasAssociatedError:!0,intersectionIsOpen:!0,keys:{key:{},value:{child:!0,parse:(e,n)=>n.$.parseSchema(e)}},normalize:e=>e,defaults:{description:e=>`${e.compiledKey}: ${e.value.description}`,expected:e=>e.missingValueDescription,actual:()=>"missing"},intersections:{required:Kt,optional:Kt}});class Ta extends ei{constructor(){super(...arguments);a(this,"expression",`${this.compiledKey}: ${this.value.expression}`);a(this,"errorContext",Object.freeze({code:"required",missingValueDescription:this.value.defaultShortDescription,relativePath:[this.key],meta:this.meta}));a(this,"compiledErrorContext",st(this.errorContext))}}const li={implementation:Ua,Node:Ta},Ja=S({kind:"sequence",hasAssociatedError:!1,collapsibleKey:"variadic",keys:{prefix:{child:!0,parse:(e,n)=>{if(e.length!==0)return e.map(t=>n.$.parseSchema(t))}},optionals:{child:!0,parse:(e,n)=>{if(e.length!==0)return e.map(t=>n.$.parseSchema(t))}},defaultables:{child:e=>e.map(n=>n[0]),parse:(e,n)=>{if(e.length!==0)return e.map(t=>{const r=n.$.parseSchema(t[0]);return Zt(r,t[1],null),[r,t[1]]})},serialize:e=>e.map(n=>[n[0].collapsibleJson,se(n[1])])},variadic:{child:!0,parse:(e,n)=>n.$.parseSchema(e,n)},minVariadicLength:{parse:e=>e===0?void 0:e},postfix:{child:!0,parse:(e,n)=>{if(e.length!==0)return e.map(t=>n.$.parseSchema(t))}}},normalize:e=>{var n,t,r;if(typeof e=="string")return{variadic:e};if("variadic"in e||"prefix"in e||"defaultables"in e||"optionals"in e||"postfix"in e||"minVariadicLength"in e){if((n=e.postfix)!=null&&n.length){if(!e.variadic)return h(Ha);if((t=e.optionals)!=null&&t.length||(r=e.defaultables)!=null&&r.length)return h(di)}return e.minVariadicLength&&!e.variadic?h("minVariadicLength may not be specified without a variadic element"):e}return{variadic:e}},reduce:(e,n)=>{var c,l,u,d,p,$,y;let t=e.minVariadicLength??0;const r=((c=e.prefix)==null?void 0:c.slice())??[],i=((l=e.defaultables)==null?void 0:l.slice())??[],s=((u=e.optionals)==null?void 0:u.slice())??[],o=((d=e.postfix)==null?void 0:d.slice())??[];if(e.variadic){for(;(p=s.at(-1))!=null&&p.equals(e.variadic);)s.pop();if(s.length===0&&i.length===0)for(;($=r.at(-1))!=null&&$.equals(e.variadic);)r.pop(),t++;for(;(y=o[0])!=null&&y.equals(e.variadic);)o.shift(),t++}else s.length===0&&i.length===0&&r.push(...o.splice(0));if(t!==e.minVariadicLength||e.prefix&&e.prefix.length!==r.length)return n.node("sequence",{...e,prefix:r,defaultables:i,optionals:s,postfix:o,minVariadicLength:t},{prereduced:!0})},defaults:{description:e=>e.isVariadicOnly?`${e.variadic.nestableExpression}[]`:`[${e.tuple.map(t=>t.kind==="defaultables"?`${t.node.nestableExpression} = ${k(t.default)}`:t.kind==="optionals"?`${t.node.nestableExpression}?`:t.kind==="variadic"?`...${t.node.nestableExpression}[]`:t.node.expression).join(", ")}]`},intersections:{sequence:(e,n,t)=>{const r=Ne({l:e.tuple,r:n.tuple,disjoint:new m,result:[],fixedVariants:[],ctx:t}),i=r.disjoint.length===0?[r,...r.fixedVariants]:r.fixedVariants;return i.length===0?r.disjoint:i.length===1?t.$.node("sequence",vn(i[0].result)):t.$.node("union",i.map(s=>({proto:Array,sequence:vn(s.result)})))}}});var ir,sr,or,ar;class Va extends xe{constructor(){super(...arguments);a(this,"impliedBasis",f.intrinsic.Array.internal);a(this,"tuple",Ga(this.inner));a(this,"prefixLength",((ir=this.prefix)==null?void 0:ir.length)??0);a(this,"defaultablesLength",((sr=this.defaultables)==null?void 0:sr.length)??0);a(this,"optionalsLength",((or=this.optionals)==null?void 0:or.length)??0);a(this,"postfixLength",((ar=this.postfix)==null?void 0:ar.length)??0);a(this,"defaultablesAndOptionals",[]);a(this,"prevariadic",this.tuple.filter(t=>t.kind==="defaultables"||t.kind==="optionals"?(this.defaultablesAndOptionals.push(t.node),!0):t.kind==="prefix"));a(this,"variadicOrPostfix",re(this.variadic&&[this.variadic],this.postfix));a(this,"flatRefs",this.addFlatRefs());a(this,"isVariadicOnly",this.prevariadic.length+this.postfixLength===0);a(this,"minVariadicLength",this.inner.minVariadicLength??0);a(this,"minLength",this.prefixLength+this.minVariadicLength+this.postfixLength);a(this,"minLengthNode",this.minLength===0?null:this.$.node("minLength",this.minLength));a(this,"maxLength",this.variadic?null:this.tuple.length);a(this,"maxLengthNode",this.maxLength===null?null:this.$.node("maxLength",this.maxLength));a(this,"impliedSiblings",this.minLengthNode?this.maxLengthNode?[this.minLengthNode,this.maxLengthNode]:[this.minLengthNode]:this.maxLengthNode?[this.maxLengthNode]:[]);a(this,"defaultValueMorphs",_a(this));a(this,"defaultValueMorphsReference",this.defaultValueMorphs.length?z(this.defaultValueMorphs):void 0);a(this,"traverseAllows",(t,r)=>{for(let i=0;i<t.length;i++)if(!this.elementAtIndex(t,i).node.traverseAllows(t[i],r))return!1;return!0});a(this,"traverseApply",(t,r)=>{let i=0;for(;i<t.length;i++)H(i,()=>this.elementAtIndex(t,i).node.traverseApply(t[i],r),r)});a(this,"expression",this.description)}addFlatRefs(){return un(this.flatRefs,this.prevariadic.flatMap((t,r)=>w(t.node.flatRefs.map(i=>X([`${r}`,...i.path],i.node)),X([`${r}`],t.node)))),un(this.flatRefs,this.variadicOrPostfix.flatMap(t=>w(t.flatRefs.map(r=>X([f.intrinsic.nonNegativeIntegerString.internal,...r.path],r.node)),X([f.intrinsic.nonNegativeIntegerString.internal],t)))),this.flatRefs}elementAtIndex(t,r){if(r<this.prevariadic.length)return this.tuple[r];const i=t.length-this.postfixLength;return r>=i?{kind:"postfix",node:this.postfix[r-i]}:{kind:"variadic",node:this.variadic??M(`Unexpected attempt to access index ${r} on ${this}`)}}get element(){return this.cacheGetter("element",this.$.node("union",this.children))}compile(t){if(this.prefix)for(const[r,i]of this.prefix.entries())t.traverseKey(`${r}`,`data[${r}]`,i);for(const[r,i]of this.defaultablesAndOptionals.entries()){const s=`${r+this.prefixLength}`;t.if(`${s} >= ${t.data}.length`,()=>t.traversalKind==="Allows"?t.return(!0):t.return()),t.traverseKey(s,`data[${s}]`,i)}if(this.variadic&&(this.postfix&&t.const("firstPostfixIndex",`${t.data}.length${this.postfix?`- ${this.postfix.length}`:""}`),t.for(`i < ${this.postfix?"firstPostfixIndex":"data.length"}`,()=>t.traverseKey("i","data[i]",this.variadic),this.prevariadic.length),this.postfix))for(const[r,i]of this.postfix.entries()){const s=`firstPostfixIndex + ${r}`;t.traverseKey(s,`data[${s}]`,i)}t.traversalKind==="Allows"&&t.return(!0)}_transform(t,r){r.path.push(f.intrinsic.nonNegativeIntegerString.internal);const i=super._transform(t,r);return r.path.pop(),i}reduceJsonSchema(t,r){if(this.prevariadic.length&&(t.prefixItems=this.prevariadic.map(i=>{const s=i.node.toJsonSchemaRecurse(r);if(i.kind==="defaultables"){const o=typeof i.default=="function"?i.default():i.default;s.default=f.intrinsic.jsonData.allows(o)?o:r.fallback.defaultValue({code:"defaultValue",base:s,value:o})}return s})),this.minLength&&(t.minItems=this.minLength),this.variadic){const i=Object.assign(t,{items:this.variadic.toJsonSchemaRecurse(r)});if(this.maxLength&&(i.maxItems=this.maxLength),this.postfix){const s=this.postfix.map(o=>o.toJsonSchemaRecurse(r));t=r.fallback.arrayPostfix({code:"arrayPostfix",base:i,elements:s})}}else t.items=!1,delete t.maxItems;return t}}const mt={},_a=e=>{if(!e.defaultables)return[];const n=[];let t="[";const r=e.prefixLength+e.defaultablesLength-1;for(let i=e.prefixLength;i<=r;i++){const[s,o]=e.defaultables[i-e.prefixLength];n.push(ni(i,s,o)),t+=`${i}: ${s.id} = ${se(o)}, `}return t+="]",mt[t]??(mt[t]=n)},ui={implementation:Ja,Node:Va},Ga=e=>{const n=[];if(e.prefix)for(const t of e.prefix)n.push({kind:"prefix",node:t});if(e.defaultables)for(const[t,r]of e.defaultables)n.push({kind:"defaultables",node:t,default:r});if(e.optionals)for(const t of e.optionals)n.push({kind:"optionals",node:t});if(e.variadic&&n.push({kind:"variadic",node:e.variadic}),e.postfix)for(const t of e.postfix)n.push({kind:"postfix",node:t});return n},vn=e=>e.reduce((n,t)=>(t.kind==="variadic"?n.variadic=t.node:t.kind==="defaultables"?n.defaultables=w(n.defaultables,[[t.node,t.default]]):n[t.kind]=w(n[t.kind],t.node),n),{}),di="A postfix required element cannot follow an optional or defaultable element",Ha="A postfix element requires a variadic element",Ne=e=>{var p,$;const[n,...t]=e.l,[r,...i]=e.r;if(!n||!r)return e;const s=((p=t.at(-1))==null?void 0:p.kind)==="postfix",o=(($=i.at(-1))==null?void 0:$.kind)==="postfix",c=n.kind==="prefix"||r.kind==="prefix"?"prefix":n.kind==="postfix"||r.kind==="postfix"?"postfix":n.kind==="variadic"&&r.kind==="variadic"?"variadic":s||o?"prefix":n.kind==="defaultables"||r.kind==="defaultables"?"defaultables":"optionals";if(n.kind==="prefix"&&r.kind==="variadic"&&o){const y=Ne({...e,fixedVariants:[],r:i.map(v=>({...v,kind:"prefix"}))});y.disjoint.length===0&&e.fixedVariants.push(y)}else if(r.kind==="prefix"&&n.kind==="variadic"&&s){const y=Ne({...e,fixedVariants:[],l:t.map(v=>({...v,kind:"prefix"}))});y.disjoint.length===0&&e.fixedVariants.push(y)}const l=C(n.node,r.node,e.ctx);if(l instanceof m)if(c==="prefix"||c==="postfix")e.disjoint.push(...l.withPrefixKey(c==="prefix"?e.result.length:`-${t.length+1}`,"required")),e.result=[...e.result,{kind:c,node:f.intrinsic.never.internal}];else return c==="optionals"||c==="defaultables"?e:Ne({...e,fixedVariants:[],l:t.map(y=>({...y,kind:"prefix"})),r:t.map(y=>({...y,kind:"prefix"}))});else c==="defaultables"?(n.kind==="defaultables"&&r.kind==="defaultables"&&n.default!==r.default&&h(ti(n.default,r.default)),e.result=[...e.result,{kind:c,node:l,default:n.kind==="defaultables"?n.default:r.kind==="defaultables"?r.default:M(`Unexpected defaultable intersection from ${n.kind} and ${r.kind} elements.`)}]):e.result=[...e.result,{kind:c,node:l}];const u=e.l.length,d=e.r.length;return(n.kind!=="variadic"||u>=d&&(r.kind==="variadic"||d===1))&&(e.l=t),(r.kind!=="variadic"||d>=u&&(n.kind==="variadic"||u===1))&&(e.r=i),Ne(e)},hi=e=>n=>{var t,r;if(n.props.length||n.index){const i=((t=n.index)==null?void 0:t.map(o=>o[e]))??[];for(const o of n.props)i.push(o[e]);n.undeclared&&i.push(`+ (undeclared): ${n.undeclared}`);const s=`{ ${i.join(", ")} }`;return n.sequence?`${s} & ${n.sequence.description}`:s}return((r=n.sequence)==null?void 0:r.description)??"{}"},Wa=hi("description"),Za=hi("expression"),kn=(e,n,t)=>{const r=e.required?"required":"optional";if(!n.signature.allows(e.key))return null;const i=W(e.value,n.value,t);return i instanceof m?r==="optional"?t.node("optional",{key:e.key,value:f.intrinsic.never.internal}):i.withPrefixKey(e.key,e.kind):null},Ya=S({kind:"structure",hasAssociatedError:!1,normalize:e=>e,applyConfig:(e,n)=>!e.undeclared&&n.onUndeclaredKey!=="ignore"?{...e,undeclared:n.onUndeclaredKey}:e,keys:{required:{child:!0,parse:L("required"),reduceIo:(e,n,t)=>{n.required=w(n.required,t.map(r=>r[e]))}},optional:{child:!0,parse:L("optional"),reduceIo:(e,n,t)=>{if(e==="in"){n.optional=t.map(r=>r.in);return}for(const r of t)n[r.outProp.kind]=w(n[r.outProp.kind],r.outProp.out)}},index:{child:!0,parse:L("index")},sequence:{child:!0,parse:L("sequence")},undeclared:{parse:e=>e==="ignore"?void 0:e,reduceIo:(e,n,t)=>{t==="delete"&&(e==="in"?delete n.undeclared:n.undeclared="reject")}}},defaults:{description:Wa},intersections:{structure:(e,n,t)=>{const r={...e.inner},i={...n.inner},s=new m;if(e.undeclared){const l=e.keyof();for(const u of n.requiredKeys)l.allows(u)||s.add("presence",f.intrinsic.never.internal,n.propsByKey[u].value,{path:[u]});i.optional&&(i.optional=i.optional.filter(u=>l.allows(u.key))),i.index&&(i.index=i.index.flatMap(u=>{if(u.signature.extends(l))return u;const d=W(l,u.signature,t.$);if(d instanceof m)return[];const p=qt(d,u.value,t.$);return p.required&&(i.required=re(i.required,p.required)),p.optional&&(i.optional=re(i.optional,p.optional)),p.index??[]}))}if(n.undeclared){const l=n.keyof();for(const u of e.requiredKeys)l.allows(u)||s.add("presence",e.propsByKey[u].value,f.intrinsic.never.internal,{path:[u]});r.optional&&(r.optional=r.optional.filter(u=>l.allows(u.key))),r.index&&(r.index=r.index.flatMap(u=>{if(u.signature.extends(l))return u;const d=W(l,u.signature,t.$);if(d instanceof m)return[];const p=qt(d,u.value,t.$);return p.required&&(r.required=re(r.required,p.required)),p.optional&&(r.optional=re(r.optional,p.optional)),p.index??[]}))}const o={};(e.undeclared||n.undeclared)&&(o.undeclared=e.undeclared==="reject"||n.undeclared==="reject"?"reject":"delete");const c=We({kind:"structure",baseInner:o,l:Ze(r),r:Ze(i),roots:[],ctx:t});return c instanceof m&&s.push(...c),s.length?s:c}},reduce:(e,n)=>{if(e.index){if(!(e.required||e.optional))return;let t=!1;const r=e.required??[],i=e.optional??[],s=[...i];for(const o of e.index){for(const c of r){const l=kn(c,o,n);if(l instanceof m)return l}for(const[c,l]of i.entries()){const u=kn(l,o,n);if(u instanceof m)return u;u!==null&&(s[c]=u,t=!0)}}if(t)return n.node("structure",{...e,optional:s},{prereduced:!0})}}});var cr,lr;class Qa extends xe{constructor(){super(...arguments);a(this,"impliedBasis",f.intrinsic.object.internal);a(this,"impliedSiblings",this.children.flatMap(t=>t.impliedSiblings??[]));a(this,"props",re(this.required,this.optional));a(this,"propsByKey",N(this.props,(t,r)=>[r.key,r]));a(this,"propsByKeyReference",z(this.propsByKey));a(this,"expression",Za(this));a(this,"requiredKeys",((cr=this.required)==null?void 0:cr.map(t=>t.key))??[]);a(this,"optionalKeys",((lr=this.optional)==null?void 0:lr.map(t=>t.key))??[]);a(this,"literalKeys",[...this.requiredKeys,...this.optionalKeys]);a(this,"_keyof");a(this,"traverseAllows",(t,r)=>this._traverse("Allows",t,r));a(this,"traverseApply",(t,r)=>this._traverse("Apply",t,r));a(this,"_traverse",(t,r,i)=>{const s=(i==null?void 0:i.currentErrorCount)??0;for(let o=0;o<this.props.length;o++)if(t==="Allows"){if(!this.props[o].traverseAllows(r,i))return!1}else if(this.props[o].traverseApply(r,i),i.failFast&&i.currentErrorCount>s)return!1;if(this.sequence){if(t==="Allows"){if(!this.sequence.traverseAllows(r,i))return!1}else if(this.sequence.traverseApply(r,i),i.failFast&&i.currentErrorCount>s)return!1}if(this.index||this.undeclared==="reject"){const o=Object.keys(r);o.push(...Object.getOwnPropertySymbols(r));for(let c=0;c<o.length;c++){const l=o[c];if(this.index){for(const u of this.index)if(u.signature.traverseAllows(l,i)){if(t==="Allows"){if(!H(l,()=>u.value.traverseAllows(r[l],i),i))return!1}else if(H(l,()=>u.value.traverseApply(r[l],i),i),i.failFast&&i.currentErrorCount>s)return!1}}if(this.undeclared==="reject"&&!this.declaresKey(l)&&(t==="Allows"||(i.errorFromNodeContext({code:"predicate",expected:"removed",actual:"",relativePath:[l],meta:this.meta}),i.failFast)))return!1}}return this.structuralMorph&&i&&!i.hasError()&&i.queueMorphs([this.structuralMorph]),!0});a(this,"declaresKey",t=>{var r;return t in this.propsByKey||((r=this.index)==null?void 0:r.some(i=>i.signature.allows(t)))||this.sequence!==void 0&&f.intrinsic.nonNegativeIntegerString.allows(t)});a(this,"structuralMorphRef",this.structuralMorph&&z(this.structuralMorph))}keyof(){if(this._keyof)return this._keyof;let t=this.$.units(this.literalKeys).branches;if(this.index)for(const{signature:r}of this.index)t=t.concat(r.branches);return this._keyof=this.$.node("union",t)}map(t){return this.$.node("structure",this.props.flatMap(t).reduce((r,i)=>{const s=this.propsByKey[i.key];if(P(i))return i.kind!=="required"&&i.kind!=="optional"?h(`Map result must have kind "required" or "optional" (was ${i.kind})`):(r[i.kind]=w(r[i.kind],i),r);const o=i.kind??(s==null?void 0:s.kind)??"required",c=N(i,(l,u)=>l in Wt.implementation.keys?[l,u]:[]);return r[o]=w(r[o],this.$.node(o,c)),r},{}))}assertHasKeys(t){const r=t.filter(i=>!Fe(i,this.keyof()));if(r.length)return h(wn(this.expression,r))}get(t,...r){var l;let i,s=!1;const o=nc(t);if((typeof o=="string"||typeof o=="symbol")&&this.propsByKey[o]&&(i=this.propsByKey[o].value,s=this.propsByKey[o].required),this.index)for(const u of this.index)Fe(o,u.signature)&&(i=(i==null?void 0:i.and(u.value))??u.value);if(this.sequence&&Fe(o,f.intrinsic.nonNegativeIntegerString))if(g(o,"root"))this.sequence.variadic&&(i=(i==null?void 0:i.and(this.sequence.element))??this.sequence.element);else{const u=Number.parseInt(o);if(u<this.sequence.prevariadic.length){const d=this.sequence.prevariadic[u].node;i=(i==null?void 0:i.and(d))??d,s||(s=u<this.sequence.prefixLength)}else if(this.sequence.variadic){const d=this.$.node("union",this.sequence.variadicOrPostfix);i=(i==null?void 0:i.and(d))??d}}if(!i)return(l=this.sequence)!=null&&l.variadic&&g(o,"root")&&o.extends(f.intrinsic.number)?h(rc(o.expression,this.sequence.expression)):h(wn(this.expression,[o]));const c=i.get(...r);return s?c:c.or(f.intrinsic.undefined)}pick(...t){return this.assertHasKeys(t),this.$.node("structure",this.filterKeys("pick",t))}omit(...t){return this.assertHasKeys(t),this.$.node("structure",this.filterKeys("omit",t))}optionalize(){const{required:t,...r}=this.inner;return this.$.node("structure",{...r,optional:this.props.map(i=>i.hasKind("required")?this.$.node("optional",i.inner):i)})}require(){const{optional:t,...r}=this.inner;return this.$.node("structure",{...r,required:this.props.map(i=>i.hasKind("optional")?{key:i.key,value:i.value}:i)})}merge(t){const r=this.filterKeys("omit",[t.keyof()]);return t.required&&(r.required=w(r.required,t.required)),t.optional&&(r.optional=w(r.optional,t.optional)),t.index&&(r.index=w(r.index,t.index)),t.sequence&&(r.sequence=t.sequence),t.undeclared?r.undeclared=t.undeclared:delete r.undeclared,this.$.node("structure",r)}filterKeys(t,r){const i=Mr(this.inner),s=o=>{const c=r.some(l=>Fe(o,l));return t==="pick"?c:!c};return i.required&&(i.required=i.required.filter(o=>s(o.key))),i.optional&&(i.optional=i.optional.filter(o=>s(o.key))),i.index&&(i.index=i.index.filter(o=>s(o.signature))),i}get defaultable(){var t;return this.cacheGetter("defaultable",((t=this.optional)==null?void 0:t.filter(r=>r.hasDefault()))??[])}_compileDeclaresKey(t){const r=[];if(this.props.length&&r.push(`k in ${this.propsByKeyReference}`),this.index)for(const i of this.index)r.push(t.invoke(i.signature,{kind:"Allows",arg:"k"}));return this.sequence&&r.push("$ark.intrinsic.nonNegativeIntegerString.allows(k)"),r.join(" || ")||"false"}get structuralMorph(){return this.cacheGetter("structuralMorph",ec(this))}compile(t){t.traversalKind==="Apply"&&t.initializeErrorCount();for(const r of this.props)t.check(r),t.traversalKind==="Apply"&&t.returnIfFailFast();if(this.sequence&&(t.check(this.sequence),t.traversalKind==="Apply"&&t.returnIfFailFast()),(this.index||this.undeclared==="reject")&&(t.const("keys","Object.keys(data)"),t.line("keys.push(...Object.getOwnPropertySymbols(data))"),t.for("i < keys.length",()=>this.compileExhaustiveEntry(t))),t.traversalKind==="Allows")return t.return(!0);this.structuralMorphRef&&t.if("ctx && !ctx.hasError()",()=>(t.line("ctx.queueMorphs(["),tc(t,this),t.line("])")))}compileExhaustiveEntry(t){if(t.const("k","keys[i]"),this.index)for(const r of this.index)t.if(`${t.invoke(r.signature,{arg:"k",kind:"Allows"})}`,()=>t.traverseKey("k","data[k]",r.value));return this.undeclared==="reject"&&t.if(`!(${this._compileDeclaresKey(t)})`,()=>t.traversalKind==="Allows"?t.return(!1):t.line(`ctx.errorFromNodeContext({ code: "predicate", expected: "removed", actual: "", relativePath: [k], meta: ${this.compiledMeta} })`).if("ctx.failFast",()=>t.return())),t}reduceJsonSchema(t,r){var i;switch(t.type){case"object":return this.reduceObjectJsonSchema(t,r);case"array":const s=((i=this.sequence)==null?void 0:i.reduceJsonSchema(t,r))??t;return this.props.length||this.index?r.fallback.arrayObject({code:"arrayObject",base:s,object:this.reduceObjectJsonSchema({type:"object"},r)}):s;default:return R.throwInternalOperandError("structure",t)}}reduceObjectJsonSchema(t,r){if(this.props.length){t.properties={};for(const i of this.props){const s=i.value.toJsonSchemaRecurse(r);if(typeof i.key=="symbol"){r.fallback.symbolKey({code:"symbolKey",base:t,key:i.key,value:s,optional:i.optional});continue}if(i.hasDefault()){const o=typeof i.default=="function"?i.default():i.default;s.default=f.intrinsic.jsonData.allows(o)?o:r.fallback.defaultValue({code:"defaultValue",base:s,value:o})}t.properties[i.key]=s}this.requiredKeys.length&&t.properties&&(t.required=this.requiredKeys.filter(i=>typeof i=="string"&&i in t.properties))}if(this.index)for(const i of this.index){const s=i.value.toJsonSchemaRecurse(r);if(i.signature.equals(f.intrinsic.string)){t.additionalProperties=s;continue}for(const o of i.signature.branches){if(!o.extends(f.intrinsic.string)){t=r.fallback.symbolKey({code:"symbolKey",base:t,key:null,value:s,optional:!1});continue}let c={type:"string"};if(o.hasKind("morph")&&(c=r.fallback.morph({code:"morph",base:o.in.toJsonSchemaRecurse(r),out:o.out.toJsonSchemaRecurse(r)})),!o.hasKind("intersection"))return M(`Unexpected index branch kind ${o.kind}.`);const{pattern:l}=o.inner;if(l){const u=Object.assign(c,{pattern:l[0].rule});for(let d=1;d<l.length;d++)c=r.fallback.patternIntersection({code:"patternIntersection",base:u,pattern:l[d].rule});t.patternProperties??(t.patternProperties={}),t.patternProperties[u.pattern]=s}}}return this.undeclared&&!t.additionalProperties&&(t.additionalProperties=!1),t}}const gt={},Xa=e=>{var t,r;let n="";for(let i=0;i<e.defaultable.length;i++)n+=e.defaultable[i].defaultValueMorphRef;if((t=e.sequence)!=null&&t.defaultValueMorphsReference&&(n+=(r=e.sequence)==null?void 0:r.defaultValueMorphsReference),e.undeclared==="delete"){if(n+="delete !(",e.required)for(const i of e.required)n+=i.compiledKey+" | ";if(e.optional)for(const i of e.optional)n+=i.compiledKey+" | ";if(e.index)for(const i of e.index)n+=i.signature.id+" | ";if(e.sequence)if(e.sequence.maxLength===null)n+=b.nonNegativeIntegerString.id;else for(let i=0;i<e.sequence.tuple.length;i++)n+=i+" | ";n+=")"}return n},ec=e=>{const n=Xa(e);if(!n)return;if(gt[n])return gt[n];const t=(r,i)=>{var s;for(let o=0;o<e.defaultable.length;o++)e.defaultable[o].key in r||e.defaultable[o].defaultValueMorph(r,i);if((s=e.sequence)!=null&&s.defaultables)for(let o=r.length-e.sequence.prefixLength;o<e.sequence.defaultables.length;o++)e.sequence.defaultValueMorphs[o](r,i);if(e.undeclared==="delete")for(const o in r)e.declaresKey(o)||delete r[o];return r};return gt[n]=t},tc=(e,n)=>{var i;const r=`(data${n.defaultable.some(s=>s.defaultValueMorph.length===2)||((i=n.sequence)==null?void 0:i.defaultValueMorphs.some(s=>s.length===2))?", ctx":""})`;return e.block(`${r} => `,s=>{var o;for(let c=0;c<n.defaultable.length;c++){const{serializedKey:l,defaultValueMorphRef:u}=n.defaultable[c];s.if(`!(${l} in data)`,d=>d.line(`${u}${r}`))}return(o=n.sequence)!=null&&o.defaultables&&s.for(`i < ${n.sequence.defaultables.length}`,c=>c.set("data[i]",5),`data.length - ${n.sequence.prefixLength}`),n.undeclared==="delete"&&s.forIn("data",c=>c.if(`!(${n._compileDeclaresKey(c)})`,l=>l.line("delete data[k]"))),s.return("data")})},fi={implementation:Ya,Node:Qa},nc=e=>(g(e,"root")&&e.hasKind("unit")&&(e=e.unit),typeof e=="number"&&(e=`${e}`),e),rc=(e,n)=>`${e} is not allowed as an array index on ${n}. Use the 'nonNegativeIntegerString' keyword instead.`,qt=(e,n,t)=>{const[r,i]=ts(e.branches,o=>o.hasKind("unit"));if(!r.length)return{index:t.node("index",{signature:e,value:n})};const s={};for(const o of r){const c=t.node("required",{key:o.unit,value:n});s[c.kind]=w(s[c.kind],c)}return i.length&&(s.index=t.node("index",{signature:i,value:n})),s},ic=e=>g(e,"root")?e.expression:k(e),wn=(e,n)=>`Key${n.length===1?"":"s"} ${n.map(ic).join(", ")} ${n.length===1?"does":"do"} not exist on ${e}`,at={...Ho,alias:Yt.implementation,domain:Xt.implementation,unit:ai.implementation,proto:Qe.implementation,union:oi.implementation,morph:ii.implementation,intersection:ri.implementation,divisor:Lr.implementation,pattern:Yr.implementation,predicate:zr.implementation,required:li.implementation,optional:Wt.implementation,index:ci.implementation,sequence:ui.implementation,structure:fi.implementation};f.defaultConfig=fs(Object.assign(N(at,(e,n)=>[e,n.defaults]),{jitless:ws(),clone:xs,onUndeclaredKey:"ignore",exactOptionalPropertyTypes:!0,numberAllowsNaN:!1,dateAllowsInvalid:!1,onFail:null,keywords:{},toJsonSchema:R.defaultConfig}));f.resolvedConfig=St(f.defaultConfig,f.config);const sc={...Wo,alias:Yt.Node,domain:Xt.Node,unit:ai.Node,proto:Qe.Node,union:oi.Node,morph:ii.Node,intersection:ri.Node,divisor:Lr.Node,pattern:Yr.Node,predicate:zr.Node,required:li.Node,optional:Wt.Node,index:ci.Node,sequence:ui.Node,structure:fi.Node};class Ct extends cs{get[G](){return"module"}}const pi=(e,n)=>new Ct(N(e,(t,r)=>[t,g(r,"module")?pi(r,n):n.bindReference(r)])),oc=e=>B(e)?e:"branches"in e&&B(e.branches)?e.branches:void 0,ac=(e,n)=>h(`Node of kind ${n} is not valid as a ${e} definition`),Nn=e=>`#${e} duplicates public alias ${e}`,yt={};f.ambient??(f.ambient={});let An;const mi="function $",cc=e=>gi(e,yi(e)),gi=(e,n)=>{const t=n.write(mi,4),r=n.compile()();for(const i of e)i.precompilation||(i.traverseAllows=r[`${i.id}Allows`].bind(r),i.isRoot()&&!i.allowsRequiresContext&&(i.allows=i.traverseAllows),i.traverseApply=r[`${i.id}Apply`].bind(r),r[`${i.id}Optimistic`]&&(i.traverseOptimistic=r[`${i.id}Optimistic`].bind(r)),i.precompilation=t)},yi=e=>new Ir().return(e.reduce((n,t)=>{const r=new ht({kind:"Allows"}).indent();t.compile(r);const i=r.write(`${t.id}Allows`),s=new ht({kind:"Apply"}).indent();t.compile(s);const o=s.write(`${t.id}Apply`),c=`${n}${i},
${o},
`;if(!t.hasKind("union"))return c;const l=new ht({kind:"Allows",optimistic:!0}).indent();t.compile(l);const u=l.write(`${t.id}Optimistic`);return`${c}${u},
`},`{
`)+"}");class bi{constructor(n,t){a(this,"config");a(this,"resolvedConfig");a(this,"name");a(this,"referencesById",{});a(this,"references",[]);a(this,"resolutions",{});a(this,"exportedNames",[]);a(this,"aliases",{});a(this,"resolved",!1);a(this,"nodesByHash",{});a(this,"intrinsic");a(this,"_json");a(this,"generic",(...n)=>{const t=this;return(r,i)=>new Ye(n,i?new Pr(r):r,t,t,i??null)});a(this,"units",(n,t)=>{const r=[];for(const s of n)r.includes(s)||r.push(s);const i=r.map(s=>this.node("unit",{unit:s},t));return this.node("union",i,{...t,prereduced:!0})});a(this,"lazyResolutions",[]);a(this,"schema",(n,t)=>this.finalize(this.parseSchema(n,t)));a(this,"parseSchema",(n,t)=>this.node(Je(n),n,t));a(this,"precompilation");a(this,"_exportedResolutions");a(this,"_exports");a(this,"node",(n,t,r={})=>{const i=this.preparseNode(n,t,r);if(P(i))return this.bindReference(i);const s=this.createParseContext(i),o=Xr(s),c=this.bindReference(o);return j[s.id]=c});a(this,"parse",(n,t={})=>this.finalize(this.parseDefinition(n,t)));this.config=St(f.config,t),this.resolvedConfig=St(f.resolvedConfig,t),this.name=this.resolvedConfig.name??`anonymousScope${Object.keys(yt).length}`,this.name in yt&&h(`A Scope already named ${this.name} already exists`),yt[this.name]=this;const r=Object.entries(n).map(i=>this.preparseOwnAliasEntry(...i));for(const[i,s]of r){let o=i;if(i[0]==="#"?(o=i.slice(1),o in this.aliases&&h(Nn(o)),this.aliases[o]=s):(o in this.aliases&&h(Nn(i)),this.aliases[o]=s,this.exportedNames.push(o)),!g(s,"module")&&!g(s,"generic")&&!tt(s)){const c=this.preparseOwnDefinitionFormat(s,{alias:o});this.resolutions[o]=g(c,"root")?this.bindReference(c):this.createParseContext(c).id}}An??(An=this.node("union",{branches:["string","number","object","bigint","symbol",{unit:!0},{unit:!1},{unit:void 0},{unit:null}]},{prereduced:!0})),this.nodesByHash[An.hash]=this.node("intersection",{},{prereduced:!0}),this.intrinsic=f.intrinsic?N(f.intrinsic,(i,s)=>i.startsWith("json")?[]:[i,this.bindReference(s)]):{}}get[G](){return"scope"}cacheGetter(n,t){return Object.defineProperty(this,n,{value:t}),t}get internal(){return this}get json(){return this._json||this.export(),this._json}defineSchema(n){return n}lazilyResolve(n,t){const r=this.node("alias",{reference:t??"synthetic",resolve:n},{prereduced:!0});return this.resolved||this.lazyResolutions.push(r),r}preparseNode(n,t,r){var c;let i=typeof n=="string"?n:Je(t,n);if(P(t)&&t.kind===i)return t;if(i==="alias"&&!(r!=null&&r.prereduced)){const{reference:l}=Yt.implementation.normalize(t,this);if(l.startsWith("$")){const u=this.resolveRoot(l.slice(1));t=u,i=u.kind}}else if(i==="union"&&oe(t,"object")){const l=oc(t);(l==null?void 0:l.length)===1&&(t=l[0],i=Je(t))}if(P(t)&&t.kind===i)return t;const s=at[i],o=((c=s.normalize)==null?void 0:c.call(s,t,this))??t;return P(o)?o.kind===i?o:ac(i,o.kind):{...r,$:this,kind:i,def:o,prefix:r.alias??i}}bindReference(n){let t;return P(n)?t=n.$===this?n:new n.constructor(n.attachments,this):t=n.$===this?n:new Ye(n.params,n.bodyDef,n.$,this,n.hkt),this.resolved||Object.assign(this.referencesById,t.referencesById),t}resolveRoot(n){return this.maybeResolveRoot(n)??h(ki(n))}maybeResolveRoot(n){const t=this.maybeResolve(n);if(!g(t,"generic"))return t}maybeResolveSubalias(n){return Dt(this.aliases,n)??Dt(this.ambient,n)}get ambient(){return f.ambient}maybeResolve(n){var i;const t=this.resolutions[n];if(t){if(typeof t!="string")return this.bindReference(t);const s=j[t];if(g(s,"root"))return this.resolutions[n]=s;if(g(s,"context")){if(s.phase==="resolving")return this.node("alias",{reference:`$${n}`},{prereduced:!0});if(s.phase==="resolved")return M(`Unexpected resolved context for was uncached by its scope: ${k(s)}`);s.phase="resolving";const o=this.bindReference(this.parseOwnDefinitionFormat(s.def,s));return s.phase="resolved",j[o.id]=o,j[s.id]=o,this.resolutions[n]=o}return M(`Unexpected nodesById entry for ${t}: ${k(s)}`)}let r=this.aliases[n]??((i=this.ambient)==null?void 0:i[n]);return r?(r=this.normalizeRootScopeValue(r),g(r,"generic")?this.resolutions[n]=this.bindReference(r):g(r,"module")?(r.root||h(wi(n)),this.resolutions[n]=this.bindReference(r.root)):this.resolutions[n]=this.parse(r,{alias:n})):this.maybeResolveSubalias(n)}createParseContext(n){const t=n.id??Qr(n.prefix);return j[t]=Object.assign(n,{[G]:"context",$:this,id:t,phase:"unresolved"})}traversal(n){return new ue(n,this.resolvedConfig)}import(...n){return new Ct(N(this.export(...n),(t,r)=>[`#${t}`,r]))}export(...n){if(!this._exports){this._exports={};for(const r of this.exportedNames){const i=this.aliases[r];this._exports[r]=g(i,"module")?pi(i,this):In(this.maybeResolve(r))}for(const r of this.lazyResolutions)r.resolution;if(this._exportedResolutions=vi(this,this._exports),this._json=xi(this._exportedResolutions),Object.assign(this.resolutions,this._exportedResolutions),this.references=Object.values(this.referencesById),!this.resolvedConfig.jitless){const r=yi(this.references);this.precompilation=r.write(mi,4),gi(this.references,r)}this.resolved=!0}const t=n.length?n:this.exportedNames;return new Ct(N(t,(r,i)=>[i,this._exports[i]]))}resolve(n){return this.export()[n]}parseDefinition(n,t={}){if(g(n,"root"))return this.bindReference(n);const r=this.preparseOwnDefinitionFormat(n,t);if(g(r,"root"))return this.bindReference(r);const i=this.createParseContext(r);j[i.id]=i;let s=this.bindReference(this.parseOwnDefinitionFormat(n,i));return s.isCyclic&&(s=ea(s,i.id)),j[i.id]=s,s}finalize(n){return In(n),!n.precompilation&&!this.resolvedConfig.jitless&&cc(n.references),n}}class $i extends bi{parseOwnDefinitionFormat(n,t){return Xr(t)}preparseOwnDefinitionFormat(n,t){return this.preparseNode(Je(n),n,t)}preparseOwnAliasEntry(n,t){return[n,t]}normalizeRootScopeValue(n){return n}}const In=e=>{const n=e.references.filter(t=>t.hasKind("alias"));for(const t of n){Object.assign(t.referencesById,t.resolution.referencesById);for(const r of e.references)t.id in r.referencesById&&Object.assign(r.referencesById,t.referencesById)}return e},xi=e=>N(e,(n,t)=>[n,g(t,"root")||g(t,"generic")?t.json:g(t,"module")?xi(t):M(`Unexpected resolution ${k(t)}`)]),Dt=(e,n)=>{const t=n.indexOf(".");if(t===-1)return;const r=n.slice(0,t),i=e[r];if(i===void 0)return;if(!g(i,"module"))return h(lc(r));const s=n.slice(t+1),o=i[s];if(o===void 0)return Dt(i,s);if(g(o,"root")||g(o,"generic"))return o;if(g(o,"module"))return o.root??h(wi(n));M(`Unexpected resolution for alias '${n}': ${k(o)}`)},en=(e,n)=>new $i(e,n),Pe=new $i({}),vi=(e,n)=>{const t={};for(const r in n){const i=n[r];if(g(i,"module")){const s=vi(e,i),o=N(s,(c,l)=>[`${r}.${c}`,l]);Object.assign(t,o)}else g(i,"root")||g(i,"generic")?t[r]=i:M(`Unexpected scope resolution ${k(i)}`)}return t},ki=e=>`'${e}' is unresolvable`,lc=e=>`'${e}' must reference a module to be accessed using dot syntax`,wi=e=>`Reference to submodule '${e}' must specify an alias`;Pe.export();const A=Pe.schema,tn=Pe.node;Pe.defineSchema;const Z=Pe.generic,Ni="^(?:0|[1-9]\\d*)$",uc=new RegExp(Ni);z(uc);const Ai=en({bigint:"bigint",boolean:[{unit:!1},{unit:!0}],false:{unit:!1},never:[],null:{unit:null},number:"number",object:"object",string:"string",symbol:"symbol",true:{unit:!0},unknown:{},undefined:{unit:void 0},Array,Date},{prereducedAliases:!0}).export();f.intrinsic={...Ai};const Ii=en({integer:{domain:"number",divisor:1},lengthBoundable:["string",Array],key:["string","symbol"],nonNegativeIntegerString:{domain:"string",pattern:Ni}},{prereducedAliases:!0}).export();Object.assign(f.intrinsic,Ii);const dc=en({jsonPrimitive:["string","number",{unit:!0},{unit:!1},{unit:null}],jsonObject:{domain:"object",index:{signature:"string",value:"$jsonData"}},jsonData:["$jsonPrimitive","$jsonObject"]},{prereducedAliases:!0}).export(),b={...Ai,...Ii,...dc,emptyStructure:tn("structure",{},{prereduced:!0})};f.intrinsic={...b};const hc=e=>typeof e=="string"&&e[0]==="d"&&(e[1]==="'"||e[1]==='"')&&e.at(-1)===e[1],Sn=e=>e.toString()!=="Invalid Date",fc=e=>e.slice(2,-1),Si=e=>`'${e}' could not be parsed by the Date constructor`,pc=(e,n)=>mc(e,n),mc=(e,n)=>{const t=new Date(e);if(Sn(t))return t;const r=js(e);if(r!==void 0){const i=new Date(r);if(Sn(i))return i}return n?h(n===!0?Si(e):n):void 0},On=(e,n)=>{const t=e.scanner.shiftUntil(yc[Mi[n]]);if(e.scanner.lookahead==="")return e.error($c(t,n));if(e.scanner.shift(),n==="/"){try{new RegExp(t)}catch(r){h(String(r))}e.root=e.ctx.$.node("intersection",{domain:"string",pattern:t},{prereduced:!0})}else if(T(n,Oi))e.root=e.ctx.$.node("unit",{unit:t});else{const r=pc(t,Si(t));e.root=e.ctx.$.node("unit",{meta:t,unit:r})}},Oi={"'":1,'"':1},gc={"/":1,"'":1,'"':1},Mi={"d'":"'",'d"':'"',"'":"'",'"':'"',"/":"/"},yc={"'":e=>e.lookahead==="'",'"':e=>e.lookahead==='"',"/":e=>e.lookahead==="/"},bc={'"':"double-quote","'":"single-quote","/":"forward slash"},$c=(e,n)=>`${n}${e} requires a closing ${bc[Mi[n]]}`,xc=e=>`Private type references should not include '#'. Use '${e}' instead.`,Ri="Optional definitions like 'string?' are only valid as properties in an object or tuple",Ki="Defaultable definitions like 'number = 0' are only valid as properties in an object or tuple",vc={">":!0,">=":!0},kc={"<":!0,"<=":!0},Xe={"<":">",">":"<","<=":">=",">=":"<=","==":"=="},wc=e=>`Unmatched )${e===""?"":` before ${e}`}`,qi=e=>`Missing ${e}`,Nc=(e,n)=>`Left bounds are only valid when paired with right bounds (try ...${n}${e})`,Ci=e=>`Left-bounded expressions must specify their limits using < or <= (was ${e})`,Ac=(e,n,t,r)=>`An expression may have at most one left bound (parsed ${e}${Xe[n]}, ${t}${Xe[r]})`,Ic=(e,n,t)=>Di(e,n,t,[]),Di=(e,n,t,r)=>{const i=t.parseUntilFinalizer();return r.push(i.root),i.finalizer===">"?r.length!==n.params.length?t.error(Bi(e,n.names,r.map(s=>s.expression))):r:i.finalizer===","?Di(e,n,t,r):i.error(qi(">"))},Bi=(e,n,t)=>`${e}<${n.join(", ")}> requires exactly ${n.length} args (got ${t.length}${t.length===0?"":`: ${t.join(", ")}`})`,Mn=e=>{const n=e.scanner.shiftUntilNextTerminator();n==="keyof"?e.addPrefix("keyof"):e.root=Oc(e,n)},Sc=(e,n,t)=>{if(t.scanner.shiftUntilNonWhitespace(),t.scanner.shift()!=="<")return t.error(Bi(e,n.names,[]));const i=Ic(e,n,t);return n(...i)},Oc=(e,n)=>Mc(e,n)??Rc(e,n)??e.error(n===""?e.scanner.lookahead==="#"?xc(e.shiftedByOne().scanner.shiftUntilNextTerminator()):Ei(e):ki(n)),Mc=(e,n)=>{var r;if((r=e.ctx.args)!=null&&r[n]){const i=e.ctx.args[n];return typeof i!="string"?i:e.ctx.$.node("alias",{reference:i},{prereduced:!0})}const t=e.ctx.$.maybeResolve(n);if(g(t,"root"))return t;if(t!==void 0)return g(t,"generic")?Sc(n,t,e):h(`Unexpected resolution ${k(t)}`)},Rc=(e,n)=>{const t=Fs(n);if(t!==void 0)return e.ctx.$.node("unit",{unit:t});const r=Ts(n);if(r!==void 0)return e.ctx.$.node("unit",{unit:r})},Ei=e=>{const n=e.previousOperator();return n?Pi(n,e.scanner.unscanned):Kc(e.scanner.unscanned)},Pi=(e,n="")=>`Token '${e}' requires a right operand${n?` before '${n}'`:""}`,Kc=e=>`Expected an expression${e?` before '${e}'`:""}`,zi=e=>e.scanner.lookahead===""?e.error(Ei(e)):e.scanner.lookahead==="("?e.shiftedByOne().reduceGroupOpen():e.scanner.lookaheadIsIn(gc)?On(e,e.scanner.shift()):e.scanner.lookaheadIsIn(nt)?zi(e.shiftedByOne()):e.scanner.lookahead==="d"&&e.scanner.nextLookahead in Oi?On(e,`${e.scanner.shift()}${e.scanner.shift()}`):Mn(e),ne=class ne extends Ys{shiftUntilNextTerminator(){return this.shiftUntilNonWhitespace(),this.shiftUntil(()=>this.lookahead in ne.terminatingChars)}};a(ne,"terminatingChars",{"<":1,">":1,"=":1,"|":1,"&":1,")":1,"[":1,"%":1,",":1,":":1,"?":1,"#":1,...nt}),a(ne,"finalizingLookaheads",{">":1,",":1,"":1,"=":1,"?":1}),a(ne,"lookaheadIsFinalizing",(n,t)=>n===">"?t[0]==="="?t[1]==="=":t.trimStart()===""||T(t.trimStart()[0],ne.terminatingChars):n==="="?t[0]!=="=":n===","||n==="?");let Se=ne;const qc=(e,n)=>{const t=Dc(e,n);if(e.root.hasKind("unit")){if(typeof e.root.unit=="number"){e.reduceLeftBound(e.root.unit,t),e.unsetRoot();return}if(e.root.unit instanceof Date){const r=`d'${e.root.description??e.root.unit.toISOString()}'`;e.unsetRoot(),e.reduceLeftBound(r,t);return}}return Ec(e,t)},Cc={"<":1,">":1,"=":1},Dc=(e,n)=>e.scanner.lookaheadIs("=")?`${n}${e.scanner.shift()}`:n,Rn=(e,n,t,r)=>t.extends(f.intrinsic.number)?typeof n!="number"?h(Bt(e,n,r)):e==="=="?["min","max"]:e[0]===">"?["min"]:["max"]:t.extends(f.intrinsic.lengthBoundable)?typeof n!="number"?h(Bt(e,n,r)):e==="=="?["exactLength"]:e[0]===">"?["minLength"]:["maxLength"]:t.extends(f.intrinsic.Date)?e==="=="?["after","before"]:e[0]===">"?["after"]:["before"]:h(Co(t.expression)),Bc=e=>({rule:hc(e.limit)?fc(e.limit):e.limit,exclusive:e.comparator.length===1}),Ec=(e,n)=>{const t=e.unsetRoot(),r=e.scanner.location;e.parseOperand();const i=e.unsetRoot(),s=e.scanner.sliceChars(r,e.scanner.location);if(e.root=t,!i.hasKind("unit")||typeof i.unit!="number"&&!(i.unit instanceof Date))return e.error(Bt(n,s,"right"));const o=i.unit,c=n.length===1,l=Rn(n,typeof o=="number"?o:s,t,"right");for(const d of l)e.constrainRoot(d,n==="=="?{rule:o}:{rule:o,exclusive:c});if(!e.branches.leftBound)return;if(!T(n,kc))return e.error(Ci(n));const u=Rn(e.branches.leftBound.comparator,e.branches.leftBound.limit,t,"left");e.constrainRoot(u[0],Bc(e.branches.leftBound)),e.branches.leftBound=null},Bt=(e,n,t)=>`Comparator ${t==="left"?Xe[e]:e} must be ${t==="left"?"preceded":"followed"} by a corresponding literal (was ${n})`,Pc=e=>{e.scanner.shiftUntilNonWhitespace();const n=e.scanner.shiftUntilNextTerminator();e.root=e.root.brand(n)},zc=e=>{const n=e.scanner.shiftUntilNextTerminator(),t=Us(n,{errorOnFail:Kn(n)});t===0&&e.error(Kn(0)),e.root=e.root.constrain("divisor",t)},Kn=e=>`% operator must be followed by a non-zero integer literal (was ${e})`,Li=e=>{const n=e.scanner.shift();return n===""?e.finalize(""):n==="["?e.scanner.shift()==="]"?e.setRoot(e.root.array()):e.error(Lc):n==="|"?e.scanner.lookahead===">"?e.shiftedByOne().pushRootToBranch("|>"):e.pushRootToBranch(n):n==="&"?e.pushRootToBranch(n):n===")"?e.finalizeGroup():Se.lookaheadIsFinalizing(n,e.scanner.unscanned)?e.finalize(n):T(n,Cc)?qc(e,n):n==="%"?zc(e):n==="#"?Pc(e):n in nt?Li(e):e.error(nn(n))},nn=(e,n="")=>`'${e}' is not allowed here${n&&` (should be ${n})`}`,Lc="Missing expected ']'",jc=e=>{const n=e.unsetRoot();e.parseOperand();const t=e.unsetRoot();if(!t.hasKind("unit"))return e.error(Fc(t.expression));const r=t.unit instanceof Date?()=>new Date(t.unit):t.unit;return[n,"=",r]},Fc=e=>`Default value '${e}' must a literal value`,qn=(e,n)=>{const t=n.$.maybeResolveRoot(e);if(t)return t;if(e.endsWith("[]")){const s=n.$.maybeResolveRoot(e.slice(0,-2));if(s)return s.array()}const r=new ct(new Se(e),n),i=Uc(r);return r.finalizer===">"&&h(nn(">")),i},Uc=e=>{e.parseOperand();let n=rn(e).root;return n?(e.finalizer==="="?n=jc(e):e.finalizer==="?"&&(n=[n,"?"]),e.scanner.shiftUntilNonWhitespace(),e.scanner.lookahead&&h(nn(e.scanner.lookahead)),n):M(`Root was unexpectedly unset after parsing string '${e.scanner.scanned}'`)},rn=e=>{for(;e.finalizer===void 0;)Tc(e);return e},Tc=e=>e.hasRoot()?e.parseOperator():e.parseOperand();class ct{constructor(n,t){a(this,"root");a(this,"branches",{prefixes:[],leftBound:null,intersection:null,union:null,pipe:null});a(this,"finalizer");a(this,"groups",[]);a(this,"scanner");a(this,"ctx");this.scanner=n,this.ctx=t}error(n){return h(n)}hasRoot(){return this.root!==void 0}setRoot(n){this.root=n}unsetRoot(){const n=this.root;return this.root=void 0,n}constrainRoot(...n){this.root=this.root.constrain(n[0],n[1])}finalize(n){if(this.groups.length)return this.error(qi(")"));this.finalizeBranches(),this.finalizer=n}reduceLeftBound(n,t){const r=Xe[t];if(!T(r,vc))return this.error(Ci(t));if(this.branches.leftBound)return this.error(Ac(this.branches.leftBound.limit,this.branches.leftBound.comparator,n,r));this.branches.leftBound={comparator:r,limit:n}}finalizeBranches(){if(this.assertRangeUnset(),this.branches.pipe){this.pushRootToBranch("|>"),this.root=this.branches.pipe;return}if(this.branches.union){this.pushRootToBranch("|"),this.root=this.branches.union;return}if(this.branches.intersection){this.pushRootToBranch("&"),this.root=this.branches.intersection;return}this.applyPrefixes()}finalizeGroup(){this.finalizeBranches();const n=this.groups.pop();if(!n)return this.error(wc(this.scanner.unscanned));this.branches=n}addPrefix(n){this.branches.prefixes.push(n)}applyPrefixes(){for(;this.branches.prefixes.length;){const n=this.branches.prefixes.pop();this.root=n==="keyof"?this.root.keyof():M(`Unexpected prefix '${n}'`)}}pushRootToBranch(n){var r,i,s;this.assertRangeUnset(),this.applyPrefixes();const t=this.root;this.root=void 0,this.branches.intersection=((r=this.branches.intersection)==null?void 0:r.rawAnd(t))??t,n!=="&"&&(this.branches.union=((i=this.branches.union)==null?void 0:i.rawOr(this.branches.intersection))??this.branches.intersection,this.branches.intersection=null,n!=="|"&&(this.branches.pipe=((s=this.branches.pipe)==null?void 0:s.rawPipeOnce(this.branches.union))??this.branches.union,this.branches.union=null))}parseUntilFinalizer(){return rn(new ct(this.scanner,this.ctx))}parseOperator(){return Li(this)}parseOperand(){return zi(this)}assertRangeUnset(){if(this.branches.leftBound)return this.error(Nc(this.branches.leftBound.limit,this.branches.leftBound.comparator))}reduceGroupOpen(){this.groups.push(this.branches),this.branches={prefixes:[],leftBound:null,union:null,intersection:null,pipe:null}}previousOperator(){var n;return((n=this.branches.leftBound)==null?void 0:n.comparator)??this.branches.prefixes.at(-1)??(this.branches.intersection?"&":this.branches.union?"|":this.branches.pipe?"|>":void 0)}shiftedByOne(){return this.scanner.shift(),this}}const Jc="An empty string is not a valid generic parameter name",Et=(e,n,t)=>{e.shiftUntilNonWhitespace();const r=e.shiftUntilNextTerminator();return r===""?e.lookahead===""&&n.length?n:h(Jc):(e.shiftUntilNonWhitespace(),Vc(e,r,n,t))},Cn="extends ",Vc=(e,n,t,r)=>{if(e.shiftUntilNonWhitespace(),e.unscanned.startsWith(Cn))e.jumpForward(Cn.length);else return e.lookahead===","&&e.shift(),t.push(n),Et(e,t,r);const i=rn(new ct(e,r));return t.push([n,i.root]),Et(e,t,r)};class _c extends $e{constructor(t){super((...r)=>new Ue(t)(...r),{bind:t});a(this,"$");this.$=t}in(t){return new Ue(this.$,t===void 0?void 0:this.$.parse(t))}at(t,r){return new Ue(this.$).at(t,r)}case(t,r){return new Ue(this.$).case(t,r)}}class Ue extends $e{constructor(t,r){super(i=>this.caseEntries(Object.entries(i).map(([s,o])=>s==="default"?[s,o]:[this.$.parse(s),o])));a(this,"$");a(this,"in");a(this,"key");a(this,"branches",[]);this.$=t,this.in=r}at(t,r){return this.key&&h(Hc),this.branches.length&&h(Gc),this.key=t,r?this.match(r):this}case(t,r){return this.caseEntry(this.$.parse(t),r)}caseEntry(t,r){const s=(this.key?this.$.parse({[this.key]:t}):t).pipe(r);return this.branches.push(s),this}match(t){return this(t)}strings(t){return this.caseEntries(Object.entries(t).map(([r,i])=>r==="default"?[r,i]:[this.$.node("unit",{unit:r}),i]))}caseEntries(t){for(let r=0;r<t.length;r++){const[i,s]=t[r];if(i==="default")return r!==t.length-1&&h("default may only be specified as the last key of a switch definition"),this.default(s);if(typeof s!="function")return h(`Value for case "${i}" must be a function (was ${F(s)})`);this.caseEntry(i,s)}return this}default(t){typeof t=="function"&&this.case(b.unknown,t);const r={branches:this.branches,ordered:!0};(t==="never"||t==="assert")&&(r.meta={onFail:Dn});const i=this.$.node("union",r);if(!this.in)return this.$.finalize(i);let s=this.in.pipe(i);return(t==="never"||t==="assert")&&(s=s.configureReferences({onFail:Dn},"self")),this.$.finalize(s)}}const Dn=e=>e.throw(),Gc="A key matcher must be specified before the first case i.e. match.at('foo') or match.in<object>().at('bar')",Hc="At most one key matcher may be specified per expression",ji=(e,n)=>{if(B(e)){if(e[1]==="=")return[n.$.parseOwnDefinitionFormat(e[0],n),"=",e[2]];if(e[1]==="?")return[n.$.parseOwnDefinitionFormat(e[0],n),"?"]}return Gi(e,n)},Wc="Only required keys may make their values optional, e.g. { [mySymbol]: ['number', '?'] }",Zc="Only required keys may specify default values, e.g. { value: 'number = 0' }",Yc=(e,n)=>{var o;let t;const r={},i=Ve(e);for(const[c,l]of i){const u=el(c);if(u.kind==="spread"){if(!Re(r))return h(Xc);const v=n.$.parseOwnDefinitionFormat(l,n);if(v.equals(b.object))continue;if(!v.hasKind("intersection")||!((o=v.basis)!=null&&o.equals(b.object)))return h(tl(v.expression));t=v.structure;continue}if(u.kind==="undeclared"){l!=="reject"&&l!=="delete"&&l!=="ignore"&&h(Qc(l)),r.undeclared=l;continue}const d=ji(l,n),p=u;if(u.kind==="required"){B(d)?bt(r,"optional",d[1]==="="?{key:u.normalized,value:d[0],default:d[2]}:{key:u.normalized,value:d[0]},n):bt(r,"required",{key:u.normalized,value:d},n);continue}if(B(d)&&(d[1]==="?"&&h(Wc),d[1]==="="&&h(Zc)),u.kind==="optional"){bt(r,"optional",{key:u.normalized,value:d},n);continue}const $=n.$.parseOwnDefinitionFormat(p.normalized,n),y=qt($,d,n.$);y.index&&(r.index=w(r.index,y.index)),y.required&&(r.required=w(r.required,y.required))}const s=n.$.node("structure",r);return n.$.parseSchema({domain:"object",structure:(t==null?void 0:t.merge(s))??s})},bt=(e,n,t,r)=>{e[n]=w(e[n],r.$.node(n,t))},Qc=e=>`Value of '+' key must be 'reject', 'delete', or 'ignore' (was ${k(e)})`,Xc="Spread operator may only be used as the first key in an object",el=e=>typeof e=="symbol"?{kind:"required",normalized:e}:e.at(-1)==="?"?e.at(-2)===kt?{kind:"required",normalized:`${e.slice(0,-2)}?`}:{kind:"optional",normalized:e.slice(0,-1)}:e[0]==="["&&e.at(-1)==="]"?{kind:"index",normalized:e.slice(1,-1)}:e[0]===kt&&e[1]==="["&&e.at(-1)==="]"?{kind:"required",normalized:e.slice(1)}:e==="..."?{kind:"spread"}:e==="+"?{kind:"undeclared"}:{kind:"required",normalized:e==="\\..."?"...":e==="\\+"?"+":e},tl=e=>`Spread operand must resolve to an object literal type (was ${e})`,nl=(e,n)=>hl(e)?Ji[e[0]](e,n):ul(e)?Ti[e[1]](e,n):null,rl=(e,n)=>n.$.parseOwnDefinitionFormat(e[1],n).keyof(),$t=(e,n)=>{if(e[2]===void 0)return h(Pi(e[1],""));const t=n.$.parseOwnDefinitionFormat(e[0],n),r=n.$.parseOwnDefinitionFormat(e[2],n);if(e[1]==="|")return n.$.node("union",{branches:[t,r]});const i=e[1]==="&"?W(t,r,n.$):Mt(t,r,n.$);return i instanceof m?i.throw():i},il=(e,n)=>n.$.parseOwnDefinitionFormat(e[0],n).array(),sl=(e,n)=>typeof e[2]!="function"?h(Fi("=>",e[2])):n.$.parseOwnDefinitionFormat(e[0],n).pipe(e[2]),Fi=(e,n)=>`${e===":"?"Narrow":"Morph"} expression requires a function following '${e}' (was ${typeof n})`,ol=(e,n)=>typeof e[2]!="function"?h(Fi(":",e[2])):n.$.parseOwnDefinitionFormat(e[0],n).constrain("predicate",e[2]),al=(e,n)=>n.$.parseOwnDefinitionFormat(e[0],n).configureReferences(e[2],"shallow"),Ui=e=>e,cl=Ui({"[]":il,"?":()=>h(Ri)}),ll=Ui({"|":$t,"&":$t,":":ol,"=>":sl,"|>":$t,"@":al,"=":()=>h(Ki)}),Ti={...cl,...ll},ul=e=>Ti[e[1]]!==void 0,dl=e=>e,Ji=dl({keyof:rl,instanceof:(e,n)=>{if(typeof e[1]!="function")return h(Bn(vt(e[1])));const t=e.slice(1).map(r=>typeof r=="function"?n.$.node("proto",{proto:r}):h(Bn(vt(r))));return t.length===1?t[0]:n.$.node("union",{branches:t})},"===":(e,n)=>n.$.units(e.slice(1))}),hl=e=>Ji[e[0]]!==void 0,Bn=e=>`Expected a constructor following 'instanceof' operator (was ${e})`,fl=(e,n)=>{let t=[{}],r=0;for(;r<e.length;){let i=!1;e[r]==="..."&&r<e.length-1&&(i=!0,r++);const s=ji(e[r],n),[o,c,l]=B(s)?s:[s];if(r++,i){if(!o.extends(f.intrinsic.Array))return h(gl(o.expression));t=t.flatMap(u=>o.distribute(d=>ml(Mr(u),d)))}else t=t.map(u=>c==="?"?Vi(u,o):c==="="?pl(u,o,l):Pt(u,o))}return n.$.parseSchema(t.map(i=>Re(i)?{proto:Array,exactLength:0}:{proto:Array,sequence:i}))},Pt=(e,n)=>e.defaultables||e.optionals?h(e.variadic?di:yl):(e.variadic?e.postfix=w(e.postfix,n):e.prefix=w(e.prefix,n),e),Vi=(e,n)=>e.variadic?h(_i):(e.optionals=w(e.optionals,n),e),pl=(e,n,t)=>e.variadic?h(_i):e.optionals?h(bl):(e.defaultables=w(e.defaultables,[[n,t]]),e),En=(e,n)=>(e.postfix&&h(Pn),e.variadic?e.variadic.equals(n)||h(Pn):e.variadic=n.internal,e),ml=(e,n)=>{const t=n.select({method:"find",kind:"sequence"});if(!t)return En(e,f.intrinsic.unknown);if(t.prefix)for(const r of t.prefix)Pt(e,r);if(t.optionals)for(const r of t.optionals)Vi(e,r);if(t.variadic&&En(e,t.variadic),t.postfix)for(const r of t.postfix)Pt(e,r);return e},gl=e=>`Spread element must be an array (was ${e})`,Pn="A tuple may have at most one variadic element",yl="A required element may not follow an optional element",_i="An optional element may not follow a variadic element",bl="A defaultable element may not follow an optional element without a default",xt={},Gi=(e,n)=>{var t;if(typeof e=="string"){if(n.args&&Object.keys(n.args).some(i=>e.includes(i)))return qn(e,n);const r=xt[t=n.$.name]??(xt[t]={});return r[e]??(r[e]=qn(e,n))}return oe(e,"object")?$l(e,n):h(zt(F(e)))},$l=(e,n)=>{const t=Ft(e);switch(t){case void 0:return g(e,"root")?e:Yc(e,n);case"Array":return xl(e,n);case"RegExp":return n.$.node("intersection",{domain:"string",pattern:e},{prereduced:!0});case"Function":{const r=tt(e)?e():e;return g(r,"root")?r:h(zt("Function"))}default:return h(zt(t??k(e)))}},xl=(e,n)=>nl(e,n)??fl(e,n),zt=e=>`Type definitions must be strings or objects (was ${e})`;class vl extends $e{constructor(n){const t=Object.assign({errors:ee,hkt:J,$:n,raw:n.parse,module:n.constructor.module,scope:n.constructor.scope,define:n.define,match:n.match,generic:n.generic,schema:n.schema,keywords:n.ambient,unit:n.unit,enumerated:n.enumerated,instanceOf:n.instanceOf,valueOf:n.valueOf,or:n.or,and:n.and,merge:n.merge,pipe:n.pipe},n.ambientAttachments);super((...r)=>{if(r.length===1)return n.parse(r[0]);if(r.length===2&&typeof r[0]=="string"&&r[0][0]==="<"&&r[0].at(-1)===">"){const i=r[0].slice(1,-1),s=n.parseGenericParams(i,{});return new Ye(s,r[1],n,n,null)}return n.parse(r)},{bind:n,attach:t})}}const Oe=f,de=class de extends bi{constructor(){super(...arguments);a(this,"unit",t=>this.units([t]));a(this,"valueOf",t=>this.units(ps(t)));a(this,"enumerated",(...t)=>this.units(t));a(this,"instanceOf",t=>this.node("proto",{proto:t},{prereduced:!0}));a(this,"or",(...t)=>this.schema(t.map(r=>this.parse(r))));a(this,"and",(...t)=>t.reduce((r,i)=>r.and(this.parse(i)),this.intrinsic.unknown));a(this,"merge",(...t)=>t.reduce((r,i)=>r.merge(this.parse(i)),this.intrinsic.object));a(this,"pipe",(...t)=>this.intrinsic.unknown.pipe(...t));a(this,"match",new _c(this));a(this,"declare",()=>({type:this.type}));a(this,"type",new vl(this))}get ambientAttachments(){if(Oe.typeAttachments)return this.cacheGetter("ambientAttachments",N(Oe.typeAttachments,(t,r)=>[t,this.bindReference(r)]))}preparseOwnAliasEntry(t,r){var c;const i=t.indexOf("<");if(i===-1){if(g(r,"module")||g(r,"generic"))return[t,r];const l=this.name==="ark"?t:t==="root"?this.name:`${this.name}.${t}`,u=(c=this.resolvedConfig.keywords)==null?void 0:c[l];return u&&(r=[r,"@",u]),[t,r]}t.at(-1)!==">"&&h("'>' must be the last character of a generic declaration in a scope");const s=t.slice(0,i),o=t.slice(i+1,-1);return[s,()=>{const l=this.parseGenericParams(o,{alias:s});return $o(l,r,this)}]}parseGenericParams(t,r){return Et(new Se(t),[],this.createParseContext({...r,def:t,prefix:"generic"}))}normalizeRootScopeValue(t){return tt(t)&&!g(t,"generic")?t():t}preparseOwnDefinitionFormat(t,r){return{...r,def:t,prefix:r.alias??"type"}}parseOwnDefinitionFormat(t,r){!(r.alias&&r.alias in this.aliases)&&!r.args&&(r.args={this:r.id});const s=Gi(t,r);if(B(s)){if(s[1]==="=")return h(Ki);if(s[1]==="?")return h(Ri)}return s}define(t){return t}};a(de,"scope",(t,r={})=>new de(t,r)),a(de,"module",(t,r={})=>de.scope(t,r).export());let et=de;const kl=Object.assign(et.scope,{define:e=>e}),x=et;class wl extends J{constructor(){super(...arguments);a(this,"description",'merge an object\'s properties onto another like `Merge(User, { isAdmin: "true" })`')}}const Nl=Z(["base",b.object],["props",b.object])(e=>e.base.merge(e.props),wl),Al=x.module({Key:b.key,Merge:Nl});class Il extends J{}const Sl=Z("element")(e=>{const n=e.element.exclude(b.Array),t=n.array();return n.rawOr(t).pipe(Me).distribute(r=>r.assertHasKind("morph").declareOut(t),A)},Il),Ol=x.module({root:b.Array,readonly:"root",index:b.nonNegativeIntegerString,liftFrom:Sl},{name:"Array"}),Lt=A(["string",Ke.FileConstructor]),Ml=Lt.rawOr(Lt.array()),zn=A({meta:"an object representing parsed form data",domain:"object",index:{signature:"string",value:Ml}}),Rl=x.module({root:["instanceof",FormData],value:Lt,parsed:zn,parse:A({in:FormData,morphs:e=>{const n={};for(const[t,r]of e)if(t in n){const i=n[t];typeof i=="string"||i instanceof Ke.FileConstructor?n[t]=[i,r]:i.push(r)}else n[t]=r;return n},declaredOut:zn})},{name:"FormData"}),Kl=x.module({Int8:["instanceof",Int8Array],Uint8:["instanceof",Uint8Array],Uint8Clamped:["instanceof",Uint8ClampedArray],Int16:["instanceof",Int16Array],Uint16:["instanceof",Uint16Array],Int32:["instanceof",Int32Array],Uint32:["instanceof",Uint32Array],Float32:["instanceof",Float32Array],Float64:["instanceof",Float64Array],BigInt64:["instanceof",BigInt64Array],BigUint64:["instanceof",BigUint64Array]},{name:"TypedArray"}),ql={Boolean:1,Number:1,String:1},Cl=x.module({...N({...pr,...gr},(e,n)=>e in ql?[]:[e,["instanceof",n]]),Array:Ol,TypedArray:Kl,FormData:Rl}),Dl=A({domain:{domain:"number",meta:"a number representing a Unix timestamp"},divisor:{rule:1,meta:"an integer representing a Unix timestamp"},min:{rule:-864e13,meta:"a Unix timestamp after -8640000000000000"},max:{rule:864e13,meta:"a Unix timestamp before 8640000000000000"},meta:"an integer representing a safe Unix timestamp"}),Bl=A({domain:"number",divisor:1}),Hi=x.module({root:b.number,integer:Bl,epoch:Dl,safe:A({domain:{domain:"number",numberAllowsNaN:!1},min:Number.MIN_SAFE_INTEGER,max:Number.MAX_SAFE_INTEGER}),NaN:["===",Number.NaN],Infinity:["===",Number.POSITIVE_INFINITY],NegativeInfinity:["===",Number.NEGATIVE_INFINITY]},{name:"number"}),I=(e,n,t)=>{const r={domain:"string",pattern:{rule:e.source,flags:e.flags,meta:n}};return t&&(r.meta={format:t}),tn("intersection",r)},Ln=I(_e,"a well-formed integer string"),Wi=x.module({root:Ln,parse:A({in:Ln,morphs:(e,n)=>{const t=Number.parseInt(e);return Number.isSafeInteger(t)?t:n.error("an integer in the range Number.MIN_SAFE_INTEGER to Number.MAX_SAFE_INTEGER")},declaredOut:b.integer})},{name:"string.integer"}),El=I(/^[\dA-Fa-f]+$/,"hex characters only"),Pl=x.module({root:I(/^(?:[\d+/A-Za-z]{4})*(?:[\d+/A-Za-z]{2}==|[\d+/A-Za-z]{3}=)?$/,"base64-encoded"),url:I(/^(?:[\w-]{4})*(?:[\w-]{2}(?:==|%3D%3D)?|[\w-]{3}(?:=|%3D)?)?$/,"base64url-encoded")},{name:"string.base64"}),jn=I(/^[A-Z].*$/,"capitalized"),zl=x.module({root:A({in:"string",morphs:e=>e.charAt(0).toUpperCase()+e.slice(1),declaredOut:jn}),preformatted:jn},{name:"string.capitalize"}),Ll=e=>{const n=e.replaceAll(/[ -]+/g,"");let t=0,r,i,s=!1;for(let o=n.length-1;o>=0;o--)r=n.substring(o,o+1),i=Number.parseInt(r,10),s?(i*=2,t+=i>=10?i%10+1:i):t+=i,s=!s;return!!(t%10===0&&n)},jl=/^(?:4\d{12}(?:\d{3,6})?|5[1-5]\d{14}|(222[1-9]|22[3-9]\d|2[3-6]\d{2}|27[01]\d|2720)\d{12}|6(?:011|5\d\d)\d{12,15}|3[47]\d{13}|3(?:0[0-5]|[68]\d)\d{11}|(?:2131|1800|35\d{3})\d{11}|6[27]\d{14}|^(81\d{14,17}))$/,Fl=A({domain:"string",pattern:{meta:"a credit card number",rule:jl.source},predicate:{meta:"a credit card number",predicate:Ll}}),Ul=/^([+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-3])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))(T((([01]\d|2[0-3])((:?)[0-5]\d)?|24:?00)([,.]\d+(?!:))?)?(\17[0-5]\d([,.]\d+)?)?([Zz]|([+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/,Tl=e=>!Number.isNaN(new Date(e).valueOf()),Fn=A({domain:"string",predicate:{meta:"a parsable date",predicate:Tl}}).assertHasKind("intersection"),Un=Wi.root.internal.narrow((e,n)=>{const t=Number.parseInt(e),r=Hi.epoch(t);return r instanceof ee?(n.errors.merge(r),!1):!0}).configure({description:"an integer string representing a safe Unix timestamp"},"self").assertHasKind("intersection"),Jl=x.module({root:Un,parse:A({in:Un,morphs:e=>new Date(e),declaredOut:b.Date})},{name:"string.date.epoch"}),Tn=I(Ul,"an ISO 8601 (YYYY-MM-DDTHH:mm:ss.sssZ) date").internal.assertHasKind("intersection"),Vl=x.module({root:Tn,parse:A({in:Tn,morphs:e=>new Date(e),declaredOut:b.Date})},{name:"string.date.iso"}),_l=x.module({root:Fn,parse:A({declaredIn:Fn,in:"string",morphs:(e,n)=>{const t=new Date(e);return Number.isNaN(t.valueOf())?n.error("a parsable date"):t},declaredOut:b.Date}),iso:Vl,epoch:Jl},{name:"string.date"}),Gl=I(/^[\w%+.-]+@[\d.A-Za-z-]+\.[A-Za-z]{2,}$/,"an email address","email"),Jn="(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])",Y=`(${Jn}[.]){3}${Jn}`,Hl=new RegExp(`^${Y}$`),O="(?:[0-9a-fA-F]{1,4})",Wl=new RegExp(`^((?:${O}:){7}(?:${O}|:)|(?:${O}:){6}(?:${Y}|:${O}|:)|(?:${O}:){5}(?::${Y}|(:${O}){1,2}|:)|(?:${O}:){4}(?:(:${O}){0,1}:${Y}|(:${O}){1,3}|:)|(?:${O}:){3}(?:(:${O}){0,2}:${Y}|(:${O}){1,4}|:)|(?:${O}:){2}(?:(:${O}){0,3}:${Y}|(:${O}){1,5}|:)|(?:${O}:){1}(?:(:${O}){0,4}:${Y}|(:${O}){1,6}|:)|(?::((?::${O}){0,5}:${Y}|(?::${O}){1,7}|:)))(%[0-9a-zA-Z.]{1,})?$`),Zl=x.module({root:["v4 | v6","@","an IP address"],v4:I(Hl,"an IPv4 address","ipv4"),v6:I(Wl,"an IPv6 address","ipv6")},{name:"string.ip"}),fe="a JSON string",Zi=e=>{if(!(e instanceof SyntaxError))throw e;return`must be ${fe} (${e})`},Yl=A({meta:fe,domain:"string",predicate:{meta:fe,predicate:(e,n)=>{try{return JSON.parse(e),!0}catch(t){return n.reject({code:"predicate",expected:fe,problem:Zi(t)})}}}}),Ql=(e,n)=>{if(e.length===0)return n.error({code:"predicate",expected:fe,actual:"empty"});try{return JSON.parse(e)}catch(t){return n.error({code:"predicate",expected:fe,problem:Zi(t)})}},Xl=x.module({root:Yl,parse:A({meta:"safe JSON string parser",in:"string",morphs:Ql,declaredOut:b.jsonObject})},{name:"string.json"}),Vn=I(/^[a-z]*$/,"only lowercase letters"),eu=x.module({root:A({in:"string",morphs:e=>e.toLowerCase(),declaredOut:Vn}),preformatted:Vn},{name:"string.lower"}),Yi=["NFC","NFD","NFKC","NFKD"],ze=N(Yi,(e,n)=>[n,A({domain:"string",predicate:t=>t.normalize(n)===t,meta:`${n}-normalized unicode`})]),lt=N(Yi,(e,n)=>[n,A({in:"string",morphs:t=>t.normalize(n),declaredOut:ze[n]})]),tu=x.module({root:lt.NFC,preformatted:ze.NFC},{name:"string.normalize.NFC"}),nu=x.module({root:lt.NFD,preformatted:ze.NFD},{name:"string.normalize.NFD"}),ru=x.module({root:lt.NFKC,preformatted:ze.NFKC},{name:"string.normalize.NFKC"}),iu=x.module({root:lt.NFKD,preformatted:ze.NFKD},{name:"string.normalize.NFKD"}),su=x.module({root:"NFC",NFC:tu,NFD:nu,NFKC:ru,NFKD:iu},{name:"string.normalize"}),_n=I(wt,"a well-formed numeric string"),ou=x.module({root:_n,parse:A({in:_n,morphs:e=>Number.parseFloat(e),declaredOut:b.number})},{name:"string.numeric"}),Gn="a regex pattern",au=A({domain:"string",predicate:{meta:Gn,predicate:(e,n)=>{try{return new RegExp(e),!0}catch(t){return n.reject({code:"predicate",expected:Gn,problem:String(t)})}}},meta:{format:"regex"}}),cu=/^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[A-Za-z-][\dA-Za-z-]*)(?:\.(?:0|[1-9]\d*|\d*[A-Za-z-][\dA-Za-z-]*))*))?(?:\+([\dA-Za-z-]+(?:\.[\dA-Za-z-]+)*))?$/,lu=I(cu,"a semantic version (see https://semver.org/)"),Hn=I(/^\S.*\S$|^\S?$/,"trimmed"),uu=x.module({root:A({in:"string",morphs:e=>e.trim(),declaredOut:Hn}),preformatted:Hn},{name:"string.trim"}),Wn=I(/^[A-Z]*$/,"only uppercase letters"),du=x.module({root:A({in:"string",morphs:e=>e.toUpperCase(),declaredOut:Wn}),preformatted:Wn},{name:"string.upper"}),hu=e=>{if(URL.canParse)return URL.canParse(e);try{return new URL(e),!0}catch{return!1}},Zn=A({domain:"string",predicate:{meta:"a URL string",predicate:hu},meta:{format:"uri"}}),fu=x.module({root:Zn,parse:A({declaredIn:Zn,in:"string",morphs:(e,n)=>{try{return new URL(e)}catch{return n.error("a URL string")}},declaredOut:A(URL)})},{name:"string.url"}),pu=x.module({root:["versioned | nil | max","@",{description:"a UUID",format:"uuid"}],"#nil":"'00000000-0000-0000-0000-000000000000'","#max":"'ffffffff-ffff-ffff-ffff-ffffffffffff'","#versioned":/[\da-f]{8}-[\da-f]{4}-[1-8][\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}/i,v1:I(/^[\da-f]{8}-[\da-f]{4}-1[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,"a UUIDv1"),v2:I(/^[\da-f]{8}-[\da-f]{4}-2[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,"a UUIDv2"),v3:I(/^[\da-f]{8}-[\da-f]{4}-3[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,"a UUIDv3"),v4:I(/^[\da-f]{8}-[\da-f]{4}-4[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,"a UUIDv4"),v5:I(/^[\da-f]{8}-[\da-f]{4}-5[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,"a UUIDv5"),v6:I(/^[\da-f]{8}-[\da-f]{4}-6[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,"a UUIDv6"),v7:I(/^[\da-f]{8}-[\da-f]{4}-7[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,"a UUIDv7"),v8:I(/^[\da-f]{8}-[\da-f]{4}-8[\da-f]{3}-[89ab][\da-f]{3}-[\da-f]{12}$/i,"a UUIDv8")},{name:"string.uuid"}),mu=x.module({root:b.string,alpha:I(/^[A-Za-z]*$/,"only letters"),alphanumeric:I(/^[\dA-Za-z]*$/,"only letters and digits 0-9"),hex:El,base64:Pl,capitalize:zl,creditCard:Fl,date:_l,digits:I(/^\d*$/,"only digits 0-9"),email:Gl,integer:Wi,ip:Zl,json:Xl,lower:eu,normalize:su,numeric:ou,regex:au,semver:lu,trim:uu,upper:du,url:fu,uuid:pu},{name:"string"}),gu=x.module({bigint:b.bigint,boolean:b.boolean,false:b.false,never:b.never,null:b.null,number:b.number,object:b.object,string:b.string,symbol:b.symbol,true:b.true,unknown:b.unknown,undefined:b.undefined}),yu=x.module({root:b.unknown,any:b.unknown},{name:"unknown"}),bu=x.module({root:b.jsonObject,stringify:tn("morph",{in:b.jsonObject,morphs:e=>JSON.stringify(e),declaredOut:b.string})},{name:"object.json"}),$u=x.module({root:b.object,json:bu},{name:"object"});class xu extends J{constructor(){super(...arguments);a(this,"description",'instantiate an object from an index signature and corresponding value type like `Record("string", "number")`')}}const vu=Z(["K",b.key],"V")(e=>({domain:"object",index:{signature:e.K,value:e.V}}),xu);class ku extends J{constructor(){super(...arguments);a(this,"description",'pick a set of properties from an object like `Pick(User, "name | age")`')}}const wu=Z(["T",b.object],["K",b.key])(e=>e.T.pick(e.K),ku);class Nu extends J{constructor(){super(...arguments);a(this,"description",'omit a set of properties from an object like `Omit(User, "age")`')}}const Au=Z(["T",b.object],["K",b.key])(e=>e.T.omit(e.K),Nu);class Iu extends J{constructor(){super(...arguments);a(this,"description","make all named properties of an object optional like `Partial(User)`")}}const Su=Z(["T",b.object])(e=>e.T.partial(),Iu);class Ou extends J{constructor(){super(...arguments);a(this,"description","make all named properties of an object required like `Required(User)`")}}const Mu=Z(["T",b.object])(e=>e.T.required(),Ou);class Ru extends J{constructor(){super(...arguments);a(this,"description",'exclude branches of a union like `Exclude("boolean", "true")`')}}const Ku=Z("T","U")(e=>e.T.exclude(e.U),Ru);class qu extends J{constructor(){super(...arguments);a(this,"description",'extract branches of a union like `Extract("0 | false | 1", "number")`')}}const Cu=Z("T","U")(e=>e.T.extract(e.U),qu),Du=x.module({Exclude:Ku,Extract:Cu,Omit:Au,Partial:Su,Pick:wu,Record:vu,Required:Mu}),ae=kl({...gu,...Du,...Cl,...Al,string:mu,number:Hi,object:$u,unknown:yu},{prereducedAliases:!0,name:"ark"}),q=ae.export();Object.assign(Oe.ambient,q);Oe.typeAttachments={string:q.string.root,number:q.number.root,bigint:q.bigint,boolean:q.boolean,symbol:q.symbol,undefined:q.undefined,null:q.null,object:q.object.root,unknown:q.unknown.root,false:q.false,true:q.true,never:q.never,arrayIndex:q.Array.index,Key:q.Key,Record:q.Record,Array:q.Array.root,Date:q.Date};const Eu=Object.assign(ae.type,Oe.typeAttachments);ae.match;ae.generic;ae.schema;ae.define;ae.declare;export{Eu as t};
